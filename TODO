Order of matrix application is window * project * subject * object * element * vector.
To change X such that YX changes to ZYX, change X to Yâ€™ZXY.
Each matrix is product of local, to-send, sent, received.
Add map from polytope to matrix, captured from dma to Triangle buffer.
Top level machine matrix operations are cont, prep, send, recv, disp.
Cont applies inverse of new transformation to local, so the switch to the new transformation is continuous.
Prep applies local to to-send, and schedules send.
Send applies to-send to sent and writes composition of all but local.
Recv either applies part of sent to received, or replaces received and compensates sent such that its delta from received is unchanged.
Disp conjoins product of local, to-send, sent, received with window, project, maybe subject, maybe object.

Figure out why shareC that uses readGeneric is linking without all functions in shareC.type.mk.
Perhaps add pragma to list structs supported by Generic and Union.

Implement window matrix maintained by vulkan.cpp. Add depth buffering.
Interpolate depth to black red orange yellow green blue purple gray.

Add multiple facets. Add PRepare to MultiOut, that records to Identz Memory.
Then Display and ComBine use Indexz to brighten close calls between facets.

Maintain pierce point by calling set for draw, calling get for read out,
handing off to thread for after read out. Add pierce point to planra test.

Put in remaining buffers. Switch to Concept shaders.
Change to two tetrahedrons manipulated separately, together, or unrigidly.

Add min and lim to BufferState to interpret idx from Center.
Add RegisterOpen bit for thread to read/write Persist to/from string which can hide show with center.

Widgets can have fixed or bound edges; only fixed edges are dragged.
Edges can have any number of inside and outside limits.
Reaching a limit provisionally adds to the edges dragged in that direction.
Dragging in the opposite direction removes provisionals.
Add share/side/frame processes that use widgets to represent filters/fields/formats.

Make planer.lua to demonstrate classification and heuristic,
plane.lua to demonstrate manipulation,
space.lua to demonstrate sampling and equivalence,
line.lua to demonstrate multimedia,
point.lua to demonstrate communication.

Add decoration to facets. Add projection of selected decoration onto otherwise transparent picture plane.
Add interpretation of visible facet metrics as sound attractors.
Add requirement of observation of other decorations in certain orders before observation of a protected decoration.
Add change of subspace in response to passing through a facet.

