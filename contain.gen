--[[
*    contain.gen
*    Copyright (C) 2019  Paul Coelho
*
*    This program is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation, either version 3 of the License, or
*    (at your option) any later version.
*
*    This program is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--]]

files = {}
os.execute("ls -1 *.c > contain.txt")
dirlist = io.open("contain.txt")
for line in dirlist:lines() do
	files[#files+1] = line
end
dirlist:close()

codes = {}
sizes = {}
pends = {}
ctypes = {}
for k,v in ipairs(files) do
	lines = {}
	file = io.open(v)
	for line in file:lines() do
		lines[#lines+1] = line
		code = nil
		ctype = nil
		if not code or code~=check then
			code,check = string.match(line,"^void put(Buf.*)%(struct Que(Que.*) %*buf")
		end
		if not code or code~=check then
			ctype,code,check = string.match(line,"^(Buf.* %*?)get(Buf.*)%(struct Que(Que.*) %*buf")
		end
		if not code or code~=check then
			code,check = string.match(line,"^int siz(Buf.*)%(struct Que(Que.*) %*buf")
		end
		if not code or code~=check then
			code,check = string.match(line,"^void put(.*)%(struct Que(.*) %*buf")
		end
		if not code or code~=check then
			ctype,code,check = string.match(line,"^(.* %*?)get(.*)%(struct Que(.*) %*buf")
		end
		if not code or code~=check then
			code,check = string.match(line,"^int siz(.*)%(struct Que(.*) %*buf")
		end
		if code and code==check and string.match(code,"^Buf.*") then
			sizes[code] = "sizeof(int)*3+sizeof(void*)*2"
			code = nil
			ctype = nil
		end
		if code and code==check then
			codes[code] = {}
			for key,val in ipairs(lines) do
				codes[code][key] = val
			end
			if ctype then
				ctypes[code] = ctype
			end
			code = nil
			ctype = nil
		end
	end
	file:close()
end
clang = " -I /usr/local/include/lua -I /usr/local/Cellar/molten-vk/1.0.34/libexec/include"
clang = "clang "..clang.." -Wno-everything -c a.c -o a.o 2> a.err > a.txt"
clangpp = "clang++ a.o -llua -lportaudio -lglfw -lGLEW -lMoltenVK"
clangpp = clangpp.." -framework CoreFoundation -framework CoreGraphics"
clangpp = clangpp.." -framework OpenGL -framework Metal -framework QuartzCore"
clangpp = clangpp.."  2>> a.err >> a.txt"
sizeofs = {"struct ","enum ",""}
pend = nil
function compile()
	if os.execute(clang) then
		if os.execute(clangpp) then
			pend = true
			return false
		end
	end
	file = io.open("a.err")
	for line in file:lines() do
		name = string.match(line,"fatal error: '(.*)' file not found")
		if name then
			pend = name;
			file:close()
			return true
		end
	end
	file:close()
	pend = false
	return false
end
for k,v in pairs(codes) do
	for key,val in ipairs(sizeofs) do
		if val == "" then siztyp = string.lower(k) else siztyp = val..k end
		file = io.open("a.c","w")
		file:write("#include <stdio.h>\n")
		for ky,vl in ipairs(v) do
			if string.match(vl,"#include \"contain.h\"") then
				file:write("#define VALUEBOX(TYPE,NAME)\n")
				file:write("#define REFERBOX(TYPE,NAME)\n")
			else
				file:write(vl.."\n")
			end
		end
		file:write("int main() {printf(\"%d\",(int)sizeof("..siztyp..")); return 0;}\n")
		file:close()
		while compile() do
			pends[#pends+1] = pend
			if not os.execute("make "..pend.." > a.txt") then
				os.exit(-1)
			end
		end
		if pend and os.execute("./a.out > a.txt") then
			file = io.open("a.txt")
			sizes[k] = file:read("*number")
			file:close()
			os.execute("rm a.c")
			break
		else
			if val == "struct " and k == "Pend" then
				os.execute("cat a.err")
				os.exit(-1)
			end
		end
		os.execute("rm a.c")
	end
end
if #arg == 0 then
	pend = "contain.c:"
	for k,v in ipairs(pends) do
		pend = pend.." "..v
	end
	print(pend)
	os.exit(0)
	--[[
else
	for k,v in pairs(codes) do
		print("codes["..k.."]("..#codes[k]..")")
	end
	for k,v in pairs(sizes) do
		print("sizes["..k.."]("..sizes[k]..")")
	end
	for k,v in pairs(pends) do
		print("pends["..k.."]("..pends[k]..")")
	end
	for k,v in pairs(ctypes) do
		print("ctypes["..k.."]("..ctypes[k]..")")
	end
	--]]
end
if (arg[1] == "contain.h") then
	file = io.open("contain.h", "w")
	file:write("#ifndef CONTAIN_H\n")
	file:write("#define CONTAIN_H\n")
	file:write("#define VALUEBOX(TYPE,NAME)\\\n")
	file:write("TYPE peek##NAME(struct Que##NAME *buf, int sub) {static TYPE box; return *get##NAME(buf,sub,&box);}\\\n")
	file:write("TYPE head##NAME(struct Que##NAME *buf) {static TYPE box; return *get##NAME(buf,0,&box);}\\\n")
	file:write("void enque##NAME(struct Que##NAME *buf, TYPE box) {put##NAME(buf,siz##NAME(buf),&box);}\\\n")
	file:write("TYPE deque##NAME(struct Que##NAME *buf) {static TYPE box = {0}; box = *get##NAME(buf,0,0); put##NAME(buf,0,0); return box;}\n")
	file:write("#define REFERBOX(TYPE,NAME)\\\n")
	file:write("TYPE *peek##NAME(struct Que##NAME *buf, int sub) {return get##NAME(buf,sub,0);}\\\n")
	file:write("TYPE *head##NAME(struct Que##NAME *buf) {return get##NAME(buf,0,0);}\\\n")
	file:write("void enque##NAME(struct Que##NAME *buf, TYPE *box) {put##NAME(buf,siz##NAME(buf),box);}\\\n")
	file:write("TYPE *deque##NAME(struct Que##NAME *buf) {static TYPE box; memcpy(&box,get##NAME(buf,0,0),sizeof(struct TYPE)); put##NAME(buf,0,0); return &box;}\n")
	for k,v in pairs(sizes) do
		file:write("typedef char arr"..k.."["..sizes[k].."];\n")
		file:write("typedef void (*init"..k..")(int sub, arr"..k.."* box);\n")
		file:write("typedef void (*done"..k..")(arr"..k.."* box);\n")
		file:write("struct Que"..k.." {\n")
		file:write("	int size;\n")
		file:write("	int head;\n")
		file:write("	int room;\n")
		file:write("	int *qual;\n")
		file:write("	arr"..k.." *data;\n")
		file:write("	init"..k.." init;\n")
		file:write("	done"..k.." done;\n")
		file:write("};\n")
	end
	file:write("\n")
	file:write("#endif")
	file:close()
end
if (arg[1] == "contain.c") then
	file = io.open("contain.c", "w")
	file:write("#include <stdlib.h>\n")
	file:write("#include <string.h>\n")
	file:write("#include \"contain.h\"\n")
	for k,v in pairs(sizes) do
		file:write("int ofs"..k.."(struct Que"..k.." *buf, int sub)\n")
		file:write("{\n")
		file:write("	return (buf->head+sub)%buf->room;\n")
		file:write("}\n")
		file:write("void big"..k.."(struct Que"..k.." *buf, int sub)\n")
		file:write("{\n")
		file:write("	while (sub >= buf->room) {\n")
		file:write("		int *save = buf->qual;\n")
		file:write("		arr"..k.." *temp = buf->data;\n")
		file:write("		buf->qual = malloc(sizeof(int)*buf->room*2);\n")
		file:write("		buf->data = malloc(sizeof(arr"..k..")*buf->room*2);\n")
		file:write("		for (int i = 0; i < buf->room*2; i++) {\n")
		file:write("			int ofs = ofs"..k.."(buf,i);\n")
		file:write("			buf->qual[i] = (i<buf->size?save[ofs]:0);\n")
		file:write("			if (buf->qual[i]) memcpy(buf->data+i,temp+ofs,sizeof(arr"..k.."));\n")
		file:write("		}\n")
		file:write("		free(save); free(temp);\n")
		file:write("		buf->room *= 2; buf->head = 0;\n")
		file:write("	}\n")
		file:write("}\n")
		file:write("void put"..k.."(struct Que"..k.." *buf, int sub, arr"..k.." *box)\n")
		file:write("{\n")
		file:write("	big"..k.."(buf,sub);\n")
		file:write("	int ofs = ofs"..k.."(buf,sub);\n")
		file:write("	if (box) {\n")
		file:write("		buf->qual[ofs] = 1; memcpy(buf->data+ofs,box,sizeof(arr"..k.."));\n")
		file:write("		if (sub < 0) {buf->head = ofs; buf->size += -sub;}\n")
		file:write("		if (sub >= buf->size) buf->size = sub+1;\n")
		file:write("	} else {\n")
		file:write("		if (buf->qual[ofs] && buf->done) buf->done(buf->data+ofs);\n")
		file:write("		buf->qual[ofs] = 0;\n")
		file:write("		while (buf->size > 0 && !buf->qual[ofs"..k.."(buf,buf->size-1)]) buf->size--;\n")
		file:write("		while (buf->size > 0 && !buf->qual[buf->head]) {buf->head = ofs"..k.."(buf,1); buf->size--;}\n")
		file:write("	}\n")
		file:write("}\n")
		file:write("arr"..k.." *get"..k.."(struct Que"..k.." *buf, int sub, arr"..k.." *box)\n")
		file:write("{\n")
		file:write("	big"..k.."(buf,sub);\n")
		file:write("	int ofs = (buf->head+sub)%buf->room;\n")
		file:write("	if (!buf->qual[ofs]) {\n")
		file:write("		buf->qual[ofs] = 1;\n")
		file:write("		while (sub < 0) {\n")
		file:write("			buf->size++;\n")
		file:write("			buf->head += buf->room-1;\n")
		file:write("			sub++;\n")
		file:write("		}\n")
		file:write("		if (sub >= buf->size) buf->size = sub+1;\n")
		file:write("		if (buf->init) buf->init(sub,buf->data+ofs);\n")
		file:write("		else {\n")
		file:write("			arr"..k.." temp = {0};\n")
		file:write("			memcpy(buf->data+ofs,&temp,"..sizes[k]..");\n")
		file:write("		}\n")
		file:write("	}\n")
		file:write("	if (box) {\n")
		file:write("		memcpy(box,buf->data+ofs,sizeof(arr"..k.."));\n")
		file:write("		return box;\n")
		file:write("	}\n")
		file:write("	return buf->data+ofs;\n")
		file:write("}\n")
		file:write("int siz"..k.."(struct Que"..k.." *buf)\n")
		file:write("{\n")
		file:write("	return buf->size;\n")
		file:write("}\n")
	end
	file:close()
end
