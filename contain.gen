--[[
*    contain.gen
*    Copyright (C) 2019  Paul Coelho
*
*    This program is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation, either version 3 of the License, or
*    (at your option) any later version.
*
*    This program is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--]]

files = {}
os.execute("ls -1 *.c > contain.txt")
dirlist = io.open("contain.txt")
for line in dirlist:lines() do
	files[#files+1] = line
end
dirlist:close()

enums = {}
structs = {}
buffers = {}
enum = nil
struct = nil
buffer = nil
code = ""
for k,v in ipairs(files) do
	file = io.open(v)
	for line in file:lines() do
		if enum then
			code = code..line
			if string.match(line,"^};$") then
				enums[enum] = code
				enum = nil
				code = ""
			else
				code = code.."\n"
			end
		elseif struct then
			code = code..line
			if string.match(line,"^};$") then
				structs[struct] = code
				struct = nil
				code = ""
			else
				code = code.."\n"
			end
		else
			enum = string.match(line,"^enum (.*) {$")
			if enum then
				code = line.."\n"
			end
			struct = string.match(line,"^struct (.*) {$")
			if struct then
				code = line.."\n"
			end
			buffer,check = string.match(line,"^void put(.*)%(struct buf(.*) %*buf")
			if not buffer or buffer~=check then
				buffer,check = string.match(line,"^void get(.*)%(struct buf(.*) %*buf")
			end
			if not buffer or buffer~=check then
				buffer,check = string.match(line,"^void siz(.*)%(struct buf(.*) %*buf")
			end
			if buffer and buffer==check and enums[buffer] then
				buffers[buffer] = enums[buffer]
				buffer = nil
			elseif buffer and buffer==check and structs[buffer] then
				buffers[buffer] = structs[buffer]
				buffer = nil
			elseif buffer and buffer==check then
				buffers[buffer] = ""
				buffer = nil
			end
		end
	end
end

typestr = {}
for k,v in pairs(buffers) do
	if v == "" then
		typestr[k] = string.lower(k)
	else
		typestr[k] = "struct "..k
	end
end
if (arg[1] == "contain.h") then
	file = io.open("contain.h", "w")
	file:write("#ifndef CONTAIN_H\n")
	file:write("#define CONTAIN_H\n")
	file:write("\n")
	for k,v in pairs(buffers) do
		if v ~= "" then
			file:write(typestr[k]..";\n")
		end
		file:write("struct buf"..k.." {\n")
		file:write("	int size;\n")
		file:write("	int head;\n")
		file:write("	int tail;\n")
		file:write("	int wrap;\n")
		file:write("	"..typestr[k].." *buf;\n")
		file:write("};\n")
	end
	file:write("\n")
	file:write("#endif")
	file:close()
end
if (arg[1] == "contain.c") then
	file = io.open("contain.c", "w")
	file:write("#include \"contain.h\"\n")
	file:write("#include \"face.h\"\n")
	for k,v in pairs(buffers) do
		file:write(v.."\n")
		file:write("void put"..k.."(struct buf"..k.." *buf, COPY("..typestr[k].."), int sub, int *box)\n")
		file:write("{}\n")
		file:write("void get"..k.."(struct buf"..k.." *buf, INIT("..typestr[k].."), int sub, int *box)\n")
		file:write("{}\n")
		file:write("int siz"..k.."(struct buf"..k.." *buf)\n")
		file:write("{return 0;}\n")
	end
	file:close()
end
