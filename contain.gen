--[[
*    contain.gen
*    Copyright (C) 2019  Paul Coelho
*
*    This program is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation, either version 3 of the License, or
*    (at your option) any later version.
*
*    This program is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--]]

files = {}
os.execute("ls -1 *.c > contain.txt")
dirlist = io.open("contain.txt")
for line in dirlist:lines() do
	files[#files+1] = line
end
dirlist:close()

enums = {}
structs = {}
buffers = {}
enum = nil
struct = nil
buffer = nil
code = ""
for k,v in ipairs(files) do
	file = io.open(v)
	for line in file:lines() do
		if enum then
			code = code..line
			if string.match(line,"^};$") then
				enums[enum] = code
				enum = nil
				code = ""
			else
				code = code.."\n"
			end
		elseif struct then
			code = code..line
			if string.match(line,"^};$") then
				structs[struct] = code
				struct = nil
				code = ""
			else
				code = code.."\n"
			end
		else
			enum = string.match(line,"^enum (.*) {$")
			if enum then
				code = line.."\n"
			end
			struct = string.match(line,"^struct (.*) {$")
			if struct then
				code = line.."\n"
			end
			buffer,check = string.match(line,"^void put(.*)%(struct buf(.*) %*buf")
			if not buffer or buffer~=check then
				buffer,check = string.match(line,"^void get(.*)%(struct buf(.*) %*buf")
			end
			if not buffer or buffer~=check then
				buffer,check = string.match(line,"^void siz(.*)%(struct buf(.*) %*buf")
			end
			if buffer and buffer==check and enums[buffer] then
				buffers[buffer] = enums[buffer]
				buffer = nil
			elseif buffer and buffer==check and structs[buffer] then
				buffers[buffer] = structs[buffer]
				buffer = nil
			elseif buffer and buffer==check then
				buffers[buffer] = ""
				buffer = nil
			end
		end
	end
end

typestr = {}
for k,v in pairs(buffers) do
	if structs[k] then
		typestr[k] = "struct "..k
	elseif enums[k] then
		typestr[k] = "enum "..k
	else
		typestr[k] = string.lower(k)
	end
end
if (arg[1] == "contain.h") then
	file = io.open("contain.h", "w")
	file:write("#ifndef CONTAIN_H\n")
	file:write("#define CONTAIN_H\n")
	file:write("\n")
	for k,v in pairs(buffers) do
		if v ~= "" then
			file:write(typestr[k]..";\n")
		end
		file:write("struct buf"..k.." {\n")
		file:write("	int size;\n")
		file:write("	int head;\n")
		file:write("	int room;\n")
		file:write("	int *init;\n")
		file:write("	"..typestr[k].." *data;\n")
		file:write("};\n")
	end
	file:write("\n")
	file:write("#endif")
	file:close()
end
if (arg[1] == "contain.c") then
	file = io.open("contain.c", "w")
	file:write("#include \"contain.h\"\n")
	file:write("#include \"face.h\"\n")
	for k,v in pairs(buffers) do
		if v ~= "" then file:write(v.."\n") end
		file:write("void big"..k.."(struct buf"..k.." *buf, COPY("..typestr[k].."), int sub)\n")
		file:write("{\n")
		file:write("	while (sub >= buf->room) {\n")
		file:write("		int *save = buf->init;\n")
		file:write("		"..typestr[k].." *temp = buf->data;\n")
		file:write("		buf->init = malloc(sizeof(int)*buf->room*2);\n")
		file:write("		buf->data = malloc(sizeof("..typestr[k]..")*buf->room*2);\n")
		file:write("		for (int i = 0; i < buf->room*2; i++) {\n")
		file:write("			int ofs = (buf->head+i)%buf->room;\n")
		file:write("			buf->init[i] = (i<buf->room?save[ofs]:0);\n")
		file:write("			if (buf->init[i]) copy(buf->data+i,temp+ofs);\n")
		file:write("		}\n")
		file:write("		free(save); free(temp);\n")
		file:write("		buf->room *= 2; buf->head = 0;\n")
		file:write("	}\n")
		file:write("}\n")
		file:write("void put"..k.."(struct buf"..k.." *buf, COPY("..typestr[k].."), int sub, "..typestr[k].." *box)\n")
		file:write("{\n")
		file:write("	big"..k.."(buf,copy,sub);\n")
		file:write("	int ofs = (buf->head+sub)%buf->room;\n")
		file:write("	if (box) {\n")
		file:write("		buf->init[ofs] = 1; copy(buf->data+ofs,box);\n")
		file:write("		if (sub >= buf->size) buf->size = sub+1;\n")
		file:write("	} else buf->init[ofs] = 0;\n")
		file:write("}\n")
		file:write("void get"..k.."(struct buf"..k.." *buf, COPY("..typestr[k].."), INIT("..typestr[k].."), int sub, "..typestr[k].." *box)\n")
		file:write("{\n")
		file:write("	big"..k.."(buf,copy,sub);\n")
		file:write("	int ofs = (buf->head+sub)%buf->room;\n")
		file:write("	if (!buf->init[ofs]) {buf->init[ofs] = 1; init(buf->data+ofs);}\n")
		file:write("	if (box) copy(box,buf->data+ofs);\n")
		file:write("}\n")
		file:write("int siz"..k.."(struct buf"..k.." *buf)\n")
		file:write("{\n")
		file:write("	return buf->size;\n")
		file:write("}\n")
	end
	file:close()
end
