dofile("type.src")

--HERE Enums
Goal = {
	"NewHub",
	"CfgHub",
	"AppHub",
	"ThdHub",
	"HubThd",
	"AppThd",
	"ThdThd",
	"HubCfg",
	"ThdErr",
	"HubErr",
}
State = {
	"Stock",
	"Start",
	"Assign",
	"Bind",
	"Wave",
	"Timer",
	"Audio",
}
Flow = {
	"Sched",
	"Back",
	"Peek",
	"Poke",
	"Store",
	"Load",
}
Command = {
	"SetCmd", -- set memory
	"GetCmd", -- get memory
	"GotCmd", -- response to GetCmd
	"UseCmd", -- notice that matrix changed
	"FixCmd", -- request to revert matrix and change plane
}
Memory = {
	"Trianglez", -- indices of vertices of facet
	"Numericz", -- distances of plane above selected base
	"Vertexz", -- intersection of backlinked planes
	"Swarmz", -- array of points around focal point
	"Texturez", -- memory for textures
	"Basisz", -- base for each dimension
	"Allmatz", -- whole view transformation
	"Fewmatz", -- matrix per set of planes
	"Onematz", -- single face transformation
	"Piercez", -- pierce point normal and valid
	"Slicez", -- plane or point index ranges
	"Stringz", -- keyboard comparison strings
	"Machinez", -- state machine lines
	"Configurez", -- configure to value
}
Configure = {
	"TriangleSize", -- refers to corners
	"TriangleLimit",
	"TriangleIndex",
	"NumericSize", -- planes for corners
	"NumericLimit",
	"NumericIndex",
	"VertexSize", -- corners of frame
	"VertexLimit",
	"VertexIndex",
	"PierceSize", -- result of compute
	"PierceLimit",
	"PierceIndex",
	"ObjectSize", -- per polytope matrix
	"ObjectLimit",
	"ObjectIndex",
	"SwarmSize", -- early warning system
	"SwarmLimit",
	"SwarmIndex",
	"TextureSize", -- how to decorate
	"TextureLimit",
	"TextureIndex",
	"SliceSize", -- ranges per draw
	"SliceLimit",
	"SliceIndex",
	"StringSize", -- to compare to
	"StringLimit",
	"StringIndex",
	"MachineLimit", -- vending machine lines
	"MachineSize",
	"MachineIndex",
	"RegisterLine", -- state of machine
	"RegisterNest",
	"RegisterHint", -- argument from graphics
	"RegisterCompare", -- index into strings
	"RegisterDone", -- shaders running count
	"RegisterOpen", -- windows open count
	"ClientCommand", -- fields from client
	"ClientMemory",
	"ClientSize",
	"ClientIndex",
	"ClientSelf",
	"StateResponse", -- fields to client
	"StateIndex",
	"StateXform",
	"StateSelect",
	"ArgumentShader", -- pass to draw
	"ArgumentStart",
	"ArgumentStop",
	"ClosestLeft", -- search through pierce
	"ClosestBase",
	"ClosestNear",
	"ClosestFound",
	"UniformLeft", -- pierce point horizontal
	"UniformBase", -- pierce pont vertical
	"UniformIndex", -- manipulate plane select
	"UniformSize", -- early warning points
	"WindowLeft", -- window into screen
	"WindowBase",
	"WindowWide",
	"WindowHigh",
	"CursorLeft", -- user input mouse
	"CursorBase",
	"CursorAngle",
	"ButtonClick", -- user input button
	"ButtonDrag",
	"ButtonPress", -- user input keyboard
	"ButtonHold",
}
Transfer = {
	"Read", -- read internal pipe
	"Write", -- write external pipe
	"Save", -- client, pierce, or query to configure
	"Copy", -- configure to configure
	"Force", -- machine to configure
	"Forces", -- script to configure
	"Collect", -- query to collect
	"Setup", -- configure to client
	"Clear", -- identity to matrix
	"Invert", -- invert in matrix
	"Manip", -- manip to matrix
	"Follow", -- multiply to matrix
	"Precede", -- multiply by matrix
	"Give", -- dma to gpu
	"Keep", -- dma to cpu
	"Draw", -- start shader
	"Jump", -- skip if true
	"Goto", -- jump if true
	"Jumps", -- skip to eval
	"Gotos", -- jump to eval
	"Nest", -- nest to level
	"Swap", -- exchange machine lines
}
Accumulate = {
	"Compose", -- kernel optimization
	"Maintain", -- kernel checkpoint
	"Written", -- kernel echoed
	"Towrite", -- kernel written
	"OfClient", -- client memory
}
Shader = {
	"Dipoint", -- display from triangles of points
	"Diplane", -- display from triangles of points from planes
	"Adpoint", -- find pierce points from triangles of points
	"Adplane", -- find pierce points from triangles of points from planes
	"Copoint", -- find planes from triangles of points
	"Coplane", -- find points from planes
	"Onpoint", -- fill triangle with plane shared by corners
	"Onplane", -- fill pierce with points on given plane
	"Depoint", -- copy points to pierces
	"Deplane", -- copy planes to pierces
}
Stage = {
	"Corner",
	"Fragment",
}
Special = {
	"Display",
	"Process",
	"Compute",
}
Compare = {
	"Less",
	"More",
	"Equal",
	"Nless",
	"Nmore",
	"Nequal",
}
Condition = {
	"Every",
	"None",
	"Both",
	"Eorb",
	"Norb",
}
Ture = {
	"Table",
	"Sides",
}
--HERE Constants
Initial = {
	{"Shader","Dipoint","Stage","Corner","Str","vertex_render"},
	{"Shader","Dipoint","Stage","Fragment","Str","fragment_render"},
	{"Shader","Dipoint","Special","Display"},
	{"Shader","Diplane","Stage","Corner","Str","diplane_vertex"},
	{"Shader","Diplane","Stage","Fragment","Str","diplane_fragment"},
	{"Shader","Diplane","Special","Display"},
	{"Shader","Adpoint","Str","kernel_pierce"},
	{"Shader","Adpoint","Special","Process"},
	{"Shader","Adplane","Str","adplane_compute"},
	{"Shader","Adplane","Special","Process"},
	{"Shader","Copoint","Str","copoint_compute"},
	{"Shader","Copoint","Special","Process"},
	{"Shader","Coplane","Str","coplane_compute"},
	{"Shader","Coplane","Special","Process"},
	{"Shader","Onpoint","Str","onpoint_compute"},
	{"Shader","Onpoint","Special","Process"},
	{"Shader","Onplane","Str","onplane_compute"},
	{"Shader","Onplane","Special","Process"},
	{"Shader","Depoint","Str","depoint_compute"},
	{"Shader","Depoint","Special","Process"},
	{"Shader","Deplane","Str","deplane_compute"},
	{"Shader","Deplane","Special","Process"},
}
Bootstrap = {
	{"Int","0","Str","Client(cmd:Command(SetCmd)mem:Memory(Configurez)siz:Int(3)\\\
		Machine(xfr:Transfer(None)idx:Int(-1)sns:Sense(Equal)siz:Int(1)\\\
		cfg[0]:Configure(WindowWide)val[0]:Int(512)\\\
		cfg[1]:Configure(WindowWide)val[1]:Int(512)\\\
		cfg[2]:Configure(MachineSize)val[2]:Int(3)"},
	{"Int","1","Str","Machine(xfr:Transfer(Read)))"},
	{"Int","2","Str","Machine(xfr:Transfer(Give)))"},
	{"Int","3","Str","Client(cmd:Command(SetCmd)mem:Memory(Configurez)siz:Int(3)\\\
		Machine(xfr:Transfer(None)idx:Int(-1)sns:Sense(Equal)siz:Int(2)\\\
		cfg[0]:Configure(MachineIndex)val[0]:Int(1)\\\
		cfg[1]:Configure(MachineLimit)val[1]:Int(3)"},
	{"Int","%(function yield(k) compute = \"Compute/*\"..tostring(k)..\"*/\"; return k end for k=0,2 do coroutine.yield(yield(k)) end return yield(3))","Special","%(return compute)"},
--	{"Int","0","Str","Machine(xfr:Transfer(None)idx:Int(-1)sns:Sense(Equal)siz:Int(1)\
--		cfg[0]:Configure(WindowWide)val[0]:Int(512)\
--		cfg[1]:Configure(WindowWide)val[1]:Int(512)\
--		cfg[2]:Configure(MachineSize)val[2]:Int(10)"},
--	{"Int","%(i=1($i%0i=i+1,i<9?%-1))","Str","Client(cmd:Command(SetCmd)mem:Memory(Machinez)siz:Int(1)idx:Int(%($i-1%0%-1))slf:Int(1)mch[0]:"},
--	{"Int","1","Str","Machine(xfr:Transfer(None)idx:Int(-1)sns:Sense(Equal)siz:Int(1)\
--		cfg[0]:Configure(RegisterHint)val[0]:Int%Configure(RegisterHint)))"},
--	{"Int","2","Str","Machine(xfr:Transfer(Read)))"},
--	{"Int","3","Str","Machine(xfr:Transfer(Save)cfg:siz:Int(2)\
--		cfg[0]:Configure(ClientCommand)cfg[1]:Configure(ClientMemory)))"},
--	{"Int","4","Str","Machine(xfr:Transfer(None)idx:Int(-1)sns:Sense(Equal)siz:Int(1)\
--		cfg[0]:Configure(ClientCommand)val[0]:Int%Command(SetCmd)idx:Int(-1)))"},
--	{"Int","5","Str","Machine(xfr:Transfer(Eorb)idx:Int(-1)sns:Sense(Equal)siz:Int(3)\
--		cfg[0]:Configure(ClientMemory)val[0]:Int%Memory(Stringz)\
--		cfg[1]:Configure(ClientMemory)val[1]:Int%Memory(Machinez)\
--		cfg[2]:Configure(ClientMemory)val[2]:Int%Memory(Configurez)))"},
--	{"Int","6","Str","Machine(xfr:Transfer(Give)))"},
--	{"Int","7","Str","Machine(xfr:Transfer(Every)idx:Int(-1)sns:Sense(Equal)siz:Int(10)))"},
--	{"Int","8","Str","Machine(xfr:Transfer(Keep)))"},
--	{"Int","9","Str","Client(cmd:Command(SetCmd)mem:Memory(Configurez)siz:Int(3)"},
--	{"Int","9","Str","Machine(xfr:Transfer(None)idx:Int(-1)sns:Sense(Equal)siz:Int(2)\
--		cfg[0]:Configure(MachineIndex)val[0]:Int(1)\
--		cfg[1]:Configure(MachineLimit)val[1]:Int(9)"},
--	{"Int","%(i=0($i%0i=i+1,i<10?%-1))","Process","Central"},
}
--HERE Structs
File = {
	{"act","Goal",{},{}},
	{"idx","Int",{["act"]={
		["NewHub"]=true,["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubCfg"]=true,
		["ThdErr"]=true
	}},{}},
	{"loc","New",{["act"]={
		["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,["ThdThd"]=true,
		["HubCfg"]=true
	}},{}},
	{"pid","New",{["act"]={
		["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,["ThdThd"]=true
	}},{}},
	{"slf","Int",{["act"]={
		["HubCfg"]=true
	}},{}},
	{"str","Str",{["act"]={
		["NewHub"]=true,["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,
		["HubCfg"]=true,
		["ThdErr"]=true,["HubErr"]=true
	}},{}},
	{"siz","New",{
		["act"]={["ThdThd"]=true
	}},{}},
}
Term0 = {
	{"cff","Num",{},{}},
}
Term1 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{1}},
}
Term2 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{2}},
}
Term3 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{3}},
}
Nomial = {
	{"num0","Int",{},{}},
	{"trm0","Term0",{},"num0"},
	{"num1","Int",{},{}},
	{"trm1","Term1",{},"num1"},
	{"num2","Int",{},{}},
	{"trm2","Term2",{},"num2"},
	{"num3","Int",{},{}},
	{"trm3","Term3",{},"num3"},
}
Ratio = {
	{"num","Nomial",{},{}},
	{"den","Nomial",{},{}},
}
Event = {
	{"tag","State",{},{}},
	{"idx","Int",{},{}},
	{"oth","Int",{},{}},
	{"key","Num",{},{}},
	{"val","Num",{},{}},
    {"upd","Ratio",{["tag"]={["Stock"]=true}},{}},
    {"dly","Ratio",{["tag"]={["Stock"]=true}},{}},
    {"sch","Ratio",{["tag"]={["Stock"]=true}},{}},
	{"flw","Flow",{["tag"]={["Bind"]=true}},{}},
	{"siz","Int",{["tag"]={["Wave"]=true}},{}},
	{"buf","Num",{["tag"]={["Wave"]=true}},"siz"},
	{"num","Int",{["tag"]={["Timer"]=true}},{}},
	{"tot","Int",{["tag"]={["Timer"]=true}},{}},
	{"ids","Int",{["tag"]={["Timer"]=true}},"num"},
	{"req","Int",{["tag"]={["Timer"]=true}},"num"},
	{"rsp","Num",{["tag"]={["Timer"]=true}},"tot"},
	{"wrp","Num",{["tag"]={["Audio"]=true}},{}},
	{"gap","Int",{["tag"]={["Audio"]=true}},{}},
	{"cdt","Int",{["tag"]={["Audio"]=true}},{}},
	{"len","Int",{["tag"]={["Audio"]=true}},{}},
	{"enb","Int",{["tag"]={["Audio"]=true}},{}},
}
Uniform = {
	{"bas","Old",{},{3,3,4}},
	{"all","Old",{},{16}},
	{"one","Old",{},{16}},
	{"lon","Old",{},{}}, -- horizontal axis of cursor
	{"lat","Old",{},{}}, -- vertical axis of cursor
	{"idx","Int",{},{}}, -- which plane to apply one matrix to
	{"siz","Int",{},{}}, -- how many swarm points there are
	{"tsz","Int",{},{}}, -- size of trinagle buffer
	{"tlm","Int",{},{}}, -- largest triangle index
	{"tid","Int",{},{}}, -- starting trangle index
	{"nsz","Int",{},{}}, -- size of numeric buffer
	{"nlm","Int",{},{}}, -- largest numeric index
	{"nid","Int",{},{}}, -- starting numeric index
	{"vsz","Int",{},{}}, -- size of vertex buffer
	{"vlm","Int",{},{}}, -- largest vertex index
	{"vid","Int",{},{}}, -- starting vertex index
	{"psz","Int",{},{}}, -- size of pierce buffer
	{"plm","Int",{},{}}, -- largest pierce index
	{"pid","Int",{},{}}, -- starting pierce index
	{"osz","Int",{},{}}, -- size of object buffer
	{"olm","Int",{},{}}, -- largest object index
	{"oid","Int",{},{}}, -- starting object index
	{"ssz","Int",{},{}}, -- size of swarm buffer
	{"slm","Int",{},{}}, -- largest swarm index
	{"sid","Int",{},{}}, -- starting swarm index
	{"xsz","Int",{},{}}, -- size of texture buffer
	{"xlm","Int",{},{}}, -- largest texture index
	{"xid","Int",{},{}}, -- starting texture index
	{"pad","Int",{},{3}},
}
Triangle = {
	{"vtx","Int",{},{4}}, -- points of triangle
	{"num","Int",{},{}}, -- plane of points
	{"tex","Int",{},{}}, -- texture of triangle
	{"pol","Int",{},{}}, -- polytope triangle is in
	{"pad","Int",{},{}},
}
Numeric = {
	{"vec","Old",{},{4}}, -- distances above basis
	{"bas","Int",{},{}}, -- basis selector
	{"pad","Int",{},{3}},
}
Vertex = {
	{"vec","Old",{},{4}}, -- intersection of planes
	{"ref","Int",{},{3}}, -- backreference to planes
	{"pad","Int",{},{}},
}
Pierce = {
	{"fix","Old",{},{4}},
	{"nml","Old",{},{4}},
	{"vld","Int",{},{}},
	{"idx","Int",{},{}},
	{"pad","Int",{},{2}},
}
Vector = {
	{"vec","Old",{},{4}},
}
Matrix = {
	{"mat","Old",{},{16}},
}
Basis = {
	{"mat","Vector",{},{9}},
}
Slice = {
	{"idx","Int",{},{}},
	{"siz","Int",{},{}},
}
Machine = {
	{"xfr","Transfer",{},{}},
	{"siz","Int",{},{}},
	{"cfg","Configure",{["xfr"]={["Save"]=true,["Copy"]=true,["Force"]=true,["Forces"]=true,["Setup"]=true,["Jump"]=true}},"siz"},
	{"oth","Configure",{["xfr"]={["Copy"]=true}},"siz"},
	{"val","Int",{["xfr"]={["Force"]=true,["Forces"]=true,["Setup"]=true,["Jump"]=true}},"siz"},
	{"cmp","Compare",{["xfr"]={["Jump"]=true}},"siz"},
	{"cnd","Condition",{["xfr"]={["Jump"]=true,["Goto"]=true}},{}},
	{"str","Str",{["xfr"]={["Forces"]=true,["Jumps"]=true,["Gotos"]=true}},{}},
	{"idx","Int",{["xfr"]={["Jump"]=true,["Goto"]=true,["Nest"]=true,["Swap"]=true}},{}},
	{"ret","Int",{["xfr"]={["Swap"]=true}},{}},
	{"src","Accumulate",{["xfr"]={["Follow"]=true,["Precede"]=true}},{}},
	{"dst","Accumulate",{["xfr"]={["Clear"]=true,["Invert"]=true,["Manip"]=true,["Follow"]=true,["Precede"]=true}},{}},
}
Client = {
	{"cmd","Command",{},{}},
	{"mem","Memory",{},{}},
	{"siz","Int",{},{}},
	{"idx","Int",{},{}},
	{"slf","Int",{},{}},
	{"tri","Triangle",{["mem"]={["Trianglez"]=true}},"siz"},
	{"num","Numeric",{["mem"]={["Numericz"]=true}},"siz"},
	{"vtx","Vertex",{["mem"]={["Vertexz"]=true}},"siz"},
	{"few","Matrix",{["mem"]={["Fewmatz"]=true}},"siz"},
	{"swa","Vector",{["mem"]={["Swarmz"]=true}},"siz"},
	{"tex","Vector",{["mem"]={["Texturez"]=true}},"siz"},
	{"bas","Basis",{["mem"]={["Basisz"]=true}},"siz"},
	{"all","Matrix",{["mem"]={["Allmatz"]=true}},"siz"},
	{"one","Matrix",{["mem"]={["Onematz"]=true}},"siz"},
	{"pie","Pierce",{["mem"]={["Piercez"]=true}},"siz"},
	{"rng","Slice",{["mem"]={["Slicez"]=true}},"siz"},
	{"str","Str",{["mem"]={["Stringz"]=true}},"siz"},
	{"mch","Machine",{["mem"]={["Machinez"]=true}},"siz"},
	{"cfg","Configure",{["mem"]={["Configurez"]=true}},"siz"},
	{"val","Old",{["mem"]={["Configurez"]=true}},"siz"},
}
Sculpt = {
	{"cfg","Ture",{},{}},
}
--HERE
Enums,Enumz = listHere("Enums","type.gen")
Constants,Constantz = listHere("Constants","type.gen")
Structs,Structz = listHere("Structs","type.gen")
function showTypeC()
	local result = ""
	result = result.."#include \"face.h\"\n"
	result = result.."#include \"type.h\"\n"
	result = result.."#include <stdlib.h>\n"
	result = result.."#include <string.h>\n"
	result = result.."#include <stdio.h>\n"
	result = result.."#include <unistd.h>\n"
	result = result.."#include <sys/errno.h>\n"
	result = result..showCallC()
	return result
end
function showTypeH()
	local result = ""
	result = result.."#include \"proto.h\"\n"
	result = result..showCallH()
	return result
end
function showTypeHs()
	local result = ""
	result = result.."module Type where\n"
	result = result.."--\n"
	result = result.."import Face\n"
	result = result.."import System.Environment\n"
	result = result.."import System.Exit\n"
	result = result.."--\n"
	result = result..showCallHs()
	return result
end
function showTypeLua()
	local result = ""
	result = result.."require \"face\"\n"
	result = result.."--\n"
	result = result..showCallLua()
	return result
end
function showTypeSw()
	local result = ""
	result = result.."import face\n"
	result = result..showCallSw()
	return result
end
if (arg[1] == "type.dep") then
	file = io.open("type.dep", "w")
	file:close()
end
if (arg[1] == "type.h") then
	file = io.open("type.h", "w")
	file:write(showTypeH().."\n")
	file:close()
end
if (arg[1] == "type.c") then
	file = io.open("type.c", "w")
	file:write(showTypeC().."\n")
	file:close()
end
if (arg[1] == "type.hs") then
	file = io.open("type.hs", "w")
	file:write(showTypeHs().."\n")
	file:close()
end
if (arg[1] == "type.lua") then
	file = io.open("type.lua", "w")
	file:write(showTypeLua().."\n")
	file:close()
end
if (arg[1] == "type.sw") then
	file = io.open("type.sw", "w")
	file:write(showTypeSw().."\n")
	file:close()
end
