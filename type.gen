dofile("show.lua")

--HERE Enums
Goal = {
	"NewHub", -- open file
	"ThdHub",
	"CfgHub", -- set pid and forward
	"AppHub", -- set pid and forward
	"HubThd", -- lock write forwarded
	"AppThd", -- lock append forwarded
	"ThdThd", -- file change notify
	"HubCfg", -- identify file change
	"ThdErr", -- close and report
	"HubErr", -- report and exit
}
State = {
	"Stock",
	"First",
	"Assign",
	"Bind",
	"Wave",
	"Timer",
	"Audio",
}
Flow = {
	"Sched",
	"Back",
	"Peek",
	"Poke",
	"Store",
	"Load",
}
Request = {
	"SetReq", -- set memory in
	"GetReq", -- get memory in
	"GotReq", -- GetReq out with memory
	"FixReq", -- request out to change plane
	"RevReq", -- FixReq in to revert plane matrix
}
Memory = {
	-- g; gpu
	-- c; cpu
	-- a; api
	"Trianglez", -- g; indices of vertices of facet
	"Numericz", -- g; distances of plane above selected base
	"Vertexz", -- g; intersection of backlinked planes
	"Swarmz", -- g; array of points around focal point
	"Texturez", -- g; memory for textures
	"Basisz", -- g; base for each dimension
	"Allmatz", -- g,c; whole view transformation
	"Fewmatz", -- g,c; matrix per set of planes
	"Onematz", -- g,c; single face transformation
	"Piercez", -- g,c; pierce point normal and valid
	"Slicez", -- a; plane or point index ranges
	"Floatz", -- c; intermediate storage
	"Stringz", -- c; keyboard comparison strings
	"Machinez", -- c; state machine lines
	"Configurez", -- g,c,a; configure to value
}
Configure = {
	-- ws; written size; side effects
	-- cg; changed graphics; write through
	-- cp; changed parameter; used later
	-- cf; changed function; used later
	-- mv; machine volatile; read only
	-- sv; staged volatile; fill read
	-- sp; staged parameter; fill read
	-- sg; staged graphics; fill read
	-- sw; staged written; fill flush
	"TriangleSize", -- ws; written refers to corners
	"NumericSize", -- ws; written planes for corners
	"VertexSize", -- ws; written corners of frame
	"SubjectSize", -- ws; written per view matrix
	"ObjectSize", -- ws; written per polytope matrix
	"ElementSize", -- ws; written per plane matrix
	"SwarmSize", -- ws; written early warning system
	"TextureSize", -- ws; written how to decorate
	"BasisSize", -- ws; written cospace converters
	"PierceSize", -- ws; written pierce points
	"SliceSize", -- ws; written ranges per draw
	"MachineSize", -- ws; written vending machine lines
	"FloatSize", -- ws; written intermediate floats
	"UniformAll", -- cg; which subject matrix
	"UniformOne", -- cg; which element matrix
	"UniformLeft", -- cg; pierce point horizontal
	"UniformBase", -- cg; pierce pont vertical
	"UniformLong", -- cg; focal length
	"UniformIndex", -- cg; manipulate plane select
	"UniformBasis", -- cg; which cospace basis
	"UniformSize", -- cg; early warning points
	"ArgumentMicro", -- cp; pass to draw
	"ArgumentStart", -- cp;
	"ArgumentStop", -- cp;
	"RegisterMemory", -- cp; which memory
	"RegisterIndex", -- cp; which memory instance
	"RegisterTransM", -- cf; mouse function
	"RegisterTransR", -- cf; roller function
	"RegisterFormM", -- cf; mouse function
	"RegisterFormR", -- cf; roller function
	"RegisterTool", -- cf; which function
	"RegisterPrompt", -- mv; console string index
	"RegisterLine", -- mv; state of machine
	"RegisterNest", -- mv; current level
	"RegisterHint", -- mv; argument from graphics
	"RegisterDone", -- sv; shaders running count
	"RegisterOpen", -- sv; thread running mask
	"OriginLeft", -- sp; starting cursor
	"OriginBase", -- sp;
	"OriginNear", -- sp;
	"OriginAngle", -- sp;
	"ClosestFound", -- sg; search through pierce
	"ClosestLeft", -- sg;
	"ClosestBase", -- sg;
	"ClosestNear", -- sg;
	"NormalLeft", -- sg;
	"NormalBase", -- sg;
	"NormalNear", -- sg;
	"WindowLeft", -- sg; window initialization
	"WindowBase", -- sg;
	"WindowWide", -- sg;
	"WindowHigh", -- sg;
	"WindowNear", -- sg;
	"WindowFar", -- sg;
	"WindowLength", -- sg;
	"CursorLeft", -- sg; user input mouse
	"CursorBase", -- sg;
	"CursorNear", -- sg;
	"CursorAngle", -- sg;
	"CursorClick", -- sg;
	"CenterRequest", -- sw; fields to from client
	"CenterMemory", -- sw;
	"CenterSize", -- sw;
	"CenterIndex", -- sw;
	"CenterSelf", -- sw;
}
Transfer = {
	"Read", -- read internal pipe
	"Write", -- write external pipe
	"Save", -- center fields, pierce, or info to configure
	"Force", -- machine to configure
	"Comp", -- composition to center
	"Pose", -- towrite to center
	"Other", -- maintain to center
	"Glitch", -- center to maintain
	"Check", -- apply center to maintain
	"Local", -- apply cursor/fixed/mode
	"Apply", -- apply towrite to written
	"Accum", -- apply written to maintain
	"Proj", -- perspective matrix
	"Share", -- dma to cpu or gpu
	"Draw", -- start shader
	"Jump", -- skip if true
	"Goto", -- jump if true
	"Nest", -- nest to level
	"Aval", -- pass global Center to datxInsert
	"Bval", -- passes constant Center to planeBuffer
	"Cval", -- calls datxEval for Center to pass to planeBuffer
	"Dval", -- copies constant to global Center
	"Eval", -- calls datxEval for Center to copy to global
}
Trans = {
	"Slide",
	"Rotate",
	"Scale",
}
Form = {
	"Ortho",
	"Focal",
	"Normal",
}
Tool = {
	"Mouse",
	"Roller",
}
Micro = {
	"Dipoint", -- display from triangles of points
	"Diplane", -- display from triangles of points from planes
	"Adpoint", -- find pierce points from triangles of points
	"Adplane", -- find pierce points from triangles of points from planes
	"Copoint", -- find planes from triangles of points
	"Coplane", -- find points from planes
	"Onpoint", -- fill triangle with plane shared by corners
	"Onplane", -- fill pierce with points on given plane
	"Depoint", -- copy points to pierces
	"Deplane", -- copy planes to pierces
}
Code = {
	"Corner",
	"Fragment",
}
Wait = {
	"Start",
	"Stop",
	"Done",
}
Proc = {
	"External",
	"Console",
	"Window",
	"Graphics",
	"Process",
}
Struc = {
	"Table",
	"Sides",
}
Stream = {
	"Fanout", -- write to named pipes; one input, multiple outputs
	"Combine", -- buffer(s) to pipe; no input, multiple outputs
	"Buffer", -- name a buffer; one input, no output
	"Execute", -- name a filter; typ is input type, for pipe named by str in successor, with output typ in successor
}
Logic = {
	"WrpJmp",
	"WrpYld",
	"RunJmp",
	"RunYld",
	"ClrVal",
	"ClrJmp",
	"ClrYld",
	"SkpVal",
	"SkpJmp",
	"SkpYld",
	"ImmJmp",
	"ImmYld",
	"SetJmp",
}
Operate = {
	"AddOp", -- siz = 2;
	"SubOp", -- 2;
	"MulOp", -- 2;
	"DivOp", -- 2;
	"RemOp", -- 2;
	"CmpOp", -- 2; to neg zero pos
	"CndOp", -- 4; from neg zero pos
	"TotOp", -- 1; cast to type
	"ImmOp", -- 0; built in value
	"ValOp", -- 2; restore from named
	"SavOp", -- 3; save to named
	"GetOp", -- 0; value from callback
	"SetOp", -- 2; callback with value
	"InsOp", -- 2; field to struct
	"ExtOp", -- 1; field from struct
	"UnqOp", -- 0; magic number
	"EmbOp", -- 1; script embed
}
Etter = {
	"Configurey",
	"Stringy",
	"Floaty",
}
Process = {
	"Filez",
	"Holez",
	"Linez",
	"Planez",
	"Spacez",
	"Pagez",
	"Pipez",
	"Framez",
	"Wavez",
	"Tapez",
	"Phonez",
}
--HERE Constants
Initial = {
	{"Micro","Dipoint","Code","Corner","Str","vertex_render"},
	{"Micro","Dipoint","Code","Fragment","Str","fragment_render"},
	{"Micro","Diplane","Code","Corner","Str","diplane_vertex"},
	{"Micro","Diplane","Code","Fragment","Str","diplane_fragment"},
	{"Micro","Adpoint","Str","kernel_pierce"},
	{"Micro","Adplane","Str","adplane_compute"},
	{"Micro","Copoint","Str","copoint_compute"},
	{"Micro","Coplane","Str","coplane_compute"},
	{"Micro","Onpoint","Str","onpoint_compute"},
	{"Micro","Onplane","Str","onplane_compute"},
	{"Micro","Depoint","Str","depoint_compute"},
	{"Micro","Deplane","Str","deplane_compute"},
}
Bootstrap = {
	{"Int","0","Str","Machine(xfr:Transfer(Force)siz:Int(7)"..
		"cfg[0]:Configure(WindowWide)"..
		"cfg[1]:Configure(WindowHigh)"..
		"cfg[2]:Configure(MachineSize)"..
		"cfg[3]:Configure(RegisterOpen)"..
		"cfg[4]:Configure(RegisterOpen)"..
		"cfg[5]:Configure(RegisterOpen)"..
		"cfg[6]:Configure(RegisterOpen)"..
		"val[0]:Int(1024)"..
		"val[1]:Int(512)"..
		"val[2]:Int(1)"..
		"val[3]:Int(1)"..
		"val[4]:Int(3)"..
		"val[5]:Int(15)"..
		"val[6]:Int(31))"},
	{"Int","1","Str","Machine(xfr:Transfer(Bval)siz:Int(1)bvl[0]:Center("..
		"req:Request(SetReq)mem:Memory(Machinez)siz:Int(1)idx:Int(0)slf:Int(0)"..
		"mch[0]:Machine(xfr:Transfer(Force)siz:Int(1)"..
		"cfg[0]:Configure(RegisterOpen)val[0]:Int(0))))"},
}
Execname = {
	{"Process","Filez","Str","./file"},
	{"Process","Holez","Str","./hole"},
	{"Process","Linez","Str","./line"},
	{"Process","Planez","Str","./plane"},
	{"Process","Spacez","Str","./space"},
	{"Process","Pagez","Str","./page"},
	{"Process","Pipez","Str","./pipe"},
	{"Process","Framez","Str","./frame"},
	{"Process","Wavez","Str","./wave"},
	{"Process","Tapez","Str","./tape"},
	{"Process","Phonez","Str","./phone"},
}
--HERE Structs
Persist = {
	{"act","Goal",{},{}},
	{"idx","Int",{["act"]={
		["NewHub"]=true,["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubCfg"]=true,
		["ThdErr"]=true
	}},{}}, -- identifier for file
	{"loc","New",{["act"]={
		["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,["ThdThd"]=true,
		["HubCfg"]=true
	}},{}}, -- location in file
	{"pid","New",{["act"]={
		["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,["ThdThd"]=true
	}},{}}, -- process id for fifo
	{"slf","Int",{["act"]={
		["HubCfg"]=true
	}},{}}, -- whether process id is self
	{"str","Str",{["act"]={
		["NewHub"]=true,["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,
		["HubCfg"]=true,
		["ThdErr"]=true,["HubErr"]=true
	}},{}}, -- file or field
}
Term0 = {
	{"cff","Num",{},{}},
}
Term1 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{1}},
}
Term2 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{2}},
}
Term3 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{3}},
}
Nomial = {
	{"num0","Int",{},{}},
	{"trm0","Term0",{},"num0"},
	{"num1","Int",{},{}},
	{"trm1","Term1",{},"num1"},
	{"num2","Int",{},{}},
	{"trm2","Term2",{},"num2"},
	{"num3","Int",{},{}},
	{"trm3","Term3",{},"num3"},
}
Ratio = {
	{"num","Nomial",{},{}},
	{"den","Nomial",{},{}},
}
Event = { -- for line process
	{"tag","State",{},{}},
	{"idx","Int",{},{}},
	{"oth","Int",{},{}},
	{"key","Num",{},{}},
	{"val","Num",{},{}},
    {"upd","Ratio",{["tag"]={["Stock"]=true}},{}},
    {"dly","Ratio",{["tag"]={["Stock"]=true}},{}},
    {"sch","Ratio",{["tag"]={["Stock"]=true}},{}},
	{"flw","Flow",{["tag"]={["Bind"]=true}},{}},
	{"siz","Int",{["tag"]={["Wave"]=true}},{}},
	{"buf","Num",{["tag"]={["Wave"]=true}},"siz"},
	{"num","Int",{["tag"]={["Timer"]=true}},{}},
	{"tot","Int",{["tag"]={["Timer"]=true}},{}},
	{"ids","Int",{["tag"]={["Timer"]=true}},"num"},
	{"req","Int",{["tag"]={["Timer"]=true}},"num"},
	{"rsp","Num",{["tag"]={["Timer"]=true}},"tot"},
	{"wrp","Num",{["tag"]={["Audio"]=true}},{}},
	{"gap","Int",{["tag"]={["Audio"]=true}},{}},
	{"cdt","Int",{["tag"]={["Audio"]=true}},{}},
	{"len","Int",{["tag"]={["Audio"]=true}},{}},
	{"enb","Int",{["tag"]={["Audio"]=true}},{}},
}
Uniform = {
	{"all","Int",{},{}}, -- which subject to use
	{"one","Int",{},{}}, -- which element to use
	{"lon","Int",{},{}}, -- horizontal axis of cursor
	{"lat","Int",{},{}}, -- vertical axis of cursor
	{"len","Int",{},{}}, -- which subject for projection
	{"idx","Int",{},{}}, -- which plane to apply one matrix to
	{"use","Int",{},{}}, -- which basis to use
	{"siz","Int",{},{}}, -- size of swarm buffer
}
Triangle = {
	{"vtx","Int32",{},{4}}, -- points of triangle
	{"num","Int32",{},{}}, -- plane of points
	{"tex","Int32",{},{}}, -- texture of triangle
	{"pol","Int32",{},{}}, -- polytope triangle is in
	{"pad","Int32",{},{}},
}
Numeric = {
	{"vec","Old",{},{4}}, -- distances above basis
	{"bas","Int32",{},{}}, -- basis selector
	{"pad","Int32",{},{3}},
}
Vertex = {
	{"vec","Old",{},{4}}, -- intersection of planes
	{"ref","Int32",{},{3}}, -- backreference to planes
	{"pad","Int32",{},{}},
}
Pierce = {
	{"fix","Old",{},{4}},
	{"nml","Old",{},{4}},
	{"vld","Int32",{},{}},
	{"idx","Int32",{},{}},
	{"pad","Int32",{},{2}},
}
Vector = {
	{"vec","Old",{},{4}},
}
Matrix = {
	{"mat","Old",{},{16}},
}
Basis = {
	{"mat","Old",{},{36}},
}
Slice = {
	{"idx","Int",{},{}},
	{"siz","Int",{},{}},
}
Express = {
	{"opr","Operate",{},{}},
	{"siz","Int",{},{}},
	{"exp","Express",{},"siz"},
	{"val","Generic",{["opr"]={["ImmOp"]=true}},1},
	{"mem","Etter",{["opr"]={["GetOp"]=true,["SetOp"]=true}},{}},
	{"cfg","Int",{["opr"]={["GetOp"]=true,["SetOp"]=true}},{}},
	{"fld","Str",{["opr"]={["InsOp"]=true,["ExtOp"]=true}},{}},
	{"idx","Int",{["opr"]={["InsOp"]=true,["ExtOp"]=true}},{}},
}
Machine = {
	{"xfr","Transfer",{},{}},
	{"siz","Int",{},{}},
	{"sav","Configure",{["xfr"]={["Save"]=true}},"siz"},
	{"cfg","Configure",{["xfr"]={["Force"]=true}},"siz"},
	{"val","Int",{["xfr"]={["Force"]=true}},"siz"},
	{"loc","Express",{["xfr"]={["Jump"]=true,["Goto"]=true}},1},
	{"nxt","Int",{["xfr"]={["Jump"]=true,["Goto"]=true}},{}},
	{"lvl","Int",{["xfr"]={["Nest"]=true}},{}},
	{"avl","Str",{["xfr"]={["Aval"]=true}},{}},
	{"bvl","Center",{["xfr"]={["Bval"]=true}},"siz"},
	{"cvl","Express",{["xfr"]={["Cval"]=true}},"siz"},
	{"dvl","Center",{["xfr"]={["Dval"]=true}},1},
	{"evl","Express",{["xfr"]={["Eval"]=true}},1},
}
Center = {
	{"req","Request",{},{}},
	{"mem","Memory",{},{}},
	{"siz","Int",{},{}},
	{"idx","Int",{},{}},
	{"slf","Int",{},{}},
	{"tri","Triangle",{["mem"]={["Trianglez"]=true}},"siz"},
	{"num","Numeric",{["mem"]={["Numericz"]=true}},"siz"},
	{"vtx","Vertex",{["mem"]={["Vertexz"]=true}},"siz"},
	{"all","Matrix",{["mem"]={["Allmatz"]=true}},"siz"},
	{"few","Matrix",{["mem"]={["Fewmatz"]=true}},"siz"},
	{"one","Matrix",{["mem"]={["Onematz"]=true}},"siz"},
	{"swa","Vector",{["mem"]={["Swarmz"]=true}},"siz"},
	{"tex","Vector",{["mem"]={["Texturez"]=true}},"siz"},
	{"bas","Basis",{["mem"]={["Basisz"]=true}},"siz"},
	{"pie","Pierce",{["mem"]={["Piercez"]=true}},"siz"},
	{"rng","Slice",{["mem"]={["Slicez"]=true}},"siz"},
	{"flt","Old",{["mem"]={["Floatz"]=true}},"siz"},
	{"str","Str",{["mem"]={["Stringz"]=true}},"siz"},
	{"mch","Machine",{["mem"]={["Machinez"]=true}},"siz"},
	{"cfg","Configure",{["mem"]={["Configurez"]=true}},"siz"},
	{"val","Int",{["mem"]={["Configurez"]=true}},"siz"},
}
Sculpt = {
	{"cfg","Struc",{},{}},
}
Data = {
	{"siz","Int",{},{}},
	{"lim","Int",{},"siz"},
	{"jmp","Int",{},"siz"},
	{"loc","Int",{},"siz"},
	{"len","Int",{},{}},
	{"opc","Logic",{},"len"},
	{"dat","Dat",{},{}},
}
Argument = {
	{"typ","Process",{},{}},
	{"inp","Int",{},{}},
	{"out","Int",{},{}},
	{"idx","Int",{},{}},
	{"str","Str",{["typ"]={["Holez"]=true}},{}},
}
Stage = {
	{"tag","Stream",{},{}},
	{"siz","Int",{["tag"]={["Fanout"]=true}},{}},
	{"dst","Str",{["tag"]={["Fanout"]=true}},"siz"},
	{"typ","Str",{["tag"]={["Fanout"]=true,["Buffer"]=true,["Execute"]=true}},{}},
	{"str","Str",{["tag"]={["Fanout"]=true,["Buffer"]=true}},{}},
	{"url","Str",{["tag"]={["Execute"]=true}},{}},
	{"arg","Argument",{["tag"]={["Execute"]=true}},1},
	{"exp","Express",{["tag"]={["Combine"]=true}},1},
	{"num","Int",{["tag"]={["Combine"]=true}},{}},
	{"dep","Str",{["tag"]={["Combine"]=true}},"num"},
}
--HERE
Enums,Enumz = listHere("Enums","type.gen")
Constants,Constantz = listHere("Constants","type.gen")
Structs,Structz = listHere("Structs","type.gen")
enum = genericEnum(Structz,Enumz,"Tag");
struct = genericStruct(Structz,Enumz,"Tag");
Enums[#Enums+1] = "Tag"; Enumz["Tag"] = enum
Structs[#Structs+1] = "Generic"; Structz["Generic"] = struct
function showTypeC()
	local result = ""
	result = result.."#include \"face.h\"\n"
	result = result.."#include \"type.h\"\n"
	result = result.."#include <stdlib.h>\n"
	result = result.."#include <string.h>\n"
	result = result.."#include <stdio.h>\n"
	result = result.."#include <unistd.h>\n"
	result = result.."#include <sys/errno.h>\n"
	result = result..showCallC().."\n"
	result = result.."int wrapExec(struct Argument *arg, const char *fork, const char *exec) {\n"
	result = result..showIndent(1).."int idx = openFork();\n"
	result = result..showIndent(1).."if (idx < 0) return -1;\n"
	result = result..showIndent(1).."if (openCheck(idx) >= 0) {\n"
	result = result..showIndent(2).."char *str = 0;\n"
	result = result..showIndent(2).."arg->inp=openRdfd(idx); arg->out=openWrfd(idx);\n"
	result = result..showIndent(2).."showArgument(arg,&str);\n"
	result = result..showIndent(2).."openExec(exec,str); fprintf(stderr,\"%s: cannot execute file: %s\\n\",fork,exec); ERROR();}\n"
	result = result..showIndent(1).."return idx;}\n"
	result = result.."int wrapType(enum Process typ, const char *fork, const char *exec) {\n"
	result = result..showIndent(1).."struct Argument arg = {0};\n"
	result = result..showIndent(1).."arg.typ = typ;\n"
	result = result..showIndent(1).."return wrapExec(&arg,fork,exec);}\n"
	result = result.."int wrapInit(struct Argument *arg, const char *str) {\n"
	result = result..showIndent(1).."int len = 0;\n"
	result = result..showIndent(1).."if (!hideArgument(arg,str,&len)) return -1;\n"
	result = result..showIndent(1).."arg->idx = rdwrInit(arg->inp,arg->out);\n"
	result = result..showIndent(1).."return 0;}\n"
	result = result.."int wrapIdent(enum Process typ, const char *str) {\n"
	result = result..showIndent(1).."struct Argument arg = {0};\n"
	result = result..showIndent(1).."if (wrapInit(&arg,str) < 0 || arg.typ != typ) return -1;\n"
	result = result..showIndent(1).."return arg.idx;}"
	return result
end
function showTypeH()
	local result = ""
	result = result.."#include \"proto.h\"\n"
	result = result..showCallH().."\n"
	result = result.."int wrapExec(struct Argument *arg, const char *fork, const char *exec);\n"
	result = result.."int wrapType(enum Process typ, const char *fork, const char *exec);\n"
	result = result.."int wrapInit(struct Argument *arg, const char *str);"
	result = result.."int wrapIdent(enum Process typ, const char *str);\n"
	return result
end
function showTypeHs()
	local result = ""
	result = result.."module Type where\n"
	result = result.."--\n"
	result = result.."import Face\n"
	result = result.."import System.Environment\n"
	result = result.."import System.IO\n"
	result = result.."import Data.IORef\n"
	result = result.."import Data.Int\n"
	result = result.."import Foreign.C.Types\n"
	result = result.."--\n"
	result = result.."type Dat = [CChar]\n"
	result = result..showCallHs().."\n"
	result = result.."wrapExec :: Argument -> String -> String -> IO (Maybe Int)\n"
	result = result.."wrapExec arg fork exec = do\n"
	result = result..showIndent(1).."idx <- openFork\n"
	result = result..showIndent(1).."if idx < 0 then return Nothing else do\n"
	result = result..showIndent(2).."vld <- openCheck idx\n"
	result = result..showIndent(2).."if vld < 0 then return (Just idx) else do\n"
	result = result..showIndent(3).."inp <- openRdfd idx\n"
	result = result..showIndent(3).."out <- openWrfd idx\n"
	result = result..showIndent(3).."ptr <- newIORef \"\"\n"
	result = result..showIndent(3).."showArgument (setArgumentCinp (setArgumentCout arg out) inp) ptr\n"
	result = result..showIndent(3).."str <- readIORef ptr\n"
	result = result..showIndent(3).."openExec exec str\n"
	result = result..showIndent(3).."hPutStrLn stderr (fork ++ \": cannot execute file: \" ++ exec)\n"
	result = result..showIndent(3).."callExit (negate 1)\n"
	result = result..showIndent(3).."return Nothing\n"
	result = result.."wrapType :: Process -> String -> String -> IO (Maybe Int)\n"
	result = result.."wrapType typ fork exec = wrapExec (Argument (ArgumentA1 typ 0 0 0) ArgumentA5Bs) fork exec\n"
	result = result.."wrapInitF :: Maybe Argument -> IO (Maybe Argument)\n"
	result = result.."wrapInitF Nothing = return Nothing\n"
	result = result.."wrapInitF (Just arg) = do\n"
	result = result..showIndent(1).."idx <- rdwrInit (getArgumentCinp arg) (getArgumentCout arg)\n"
	result = result..showIndent(1).."return (Just (setArgumentCidx arg idx))\n"
	result = result.."wrapInit :: String -> IO (Maybe Argument)\n"
	result = result.."wrapInit str = newRefStr str >>= hideArgument >>= wrapInitF\n"
	result = result.."wrapIdentF :: Process -> Maybe Argument -> IO (Maybe Int)\n"
	result = result.."wrapIdentF _ Nothing = return Nothing\n"
	result = result.."wrapIdentF typ (Just arg) = if typ /= (getArgumentCtyp arg) then\n"
	result = result..showIndent(1).."return Nothing else\n"
	result = result..showIndent(1).."return (Just (getArgumentCidx arg))\n"
	result = result.."wrapIdent :: Process -> String -> IO (Maybe Int)\n"
	result = result.."wrapIdent typ str = wrapInit str >>= wrapIdentF typ\n"
	return result
end
function showTypeLua()
	local result = ""
	result = result.."require \"face\"\n"
	result = result.."--\n"
	result = result..showCallLua().."\n"
	result = result.."function wrapExec(arg,fork,exec)\n"
	result = result..showIndent(1).."idx = openFork()\n"
	result = result..showIndent(1).."if (idx < 0) then return -1 end\n"
	result = result..showIndent(1).."if (openCheck(idx) >= 0) then\n"
	result = result..showIndent(1).."arg[\"inp\"]=openRdfd(idx); arg[\"out\"]=openWrfd(idx); arg[\"idx\"]=-1\n"
	result = result..showIndent(1).."if (arg[\"typ\"] == nil) then arg[\"typ\"] = \"Processs\"end\n"
	result = result..showIndent(2).."str = showArgument(arg,\"\")\n"
	result = result..showIndent(2).."openExec(exec,str); io.stderr:write(fork..\": cannot execute file: \"..exec..\"\\n\"); os.exit(-1)\n"
	result = result..showIndent(1).."end\n"
	result = result..showIndent(1).."return idx\n"
	result = result.."end\n"
	result = result.."function wrapType(typ,fork,exec)\n"
	result = result..showIndent(1).."arg[\"typ\"] = typ\n"
	result = result..showIndent(1).."return wrapExec(arg,fork,exec)\n"
	result = result.."end\n"
	result = result.."function wrapInit(str)\n"
	result = result..showIndent(1).."arg,len = hideArgument(str,0)\n"
	result = result..showIndent(1).."if (arg == nil) then return nil end\n"
	result = result..showIndent(1).."arg[\"idx\"] = rdwrInit(arg[\"inp\"],arg[\"out\"])\n"
	result = result..showIndent(1).."return arg\n"
	result = result.."end\n"
	result = result.."function wrapIdent(typ,str)\n"
	result = result..showIndent(1).."arg = wrapInit(str)\n"
	result = result..showIndent(1).."if (arg == nil) or not (arg[\"typ\"] == typ) then return -1 end\n"
	result = result..showIndent(1).."return arg[\"idx\"]\n"
	result = result.."end"
	return result
end
if (arg[1] == "type.dep") then
	file = io.open("type.dep", "w")
	file:close()
end
if (arg[1] == "type.h") then
	file = io.open("type.h", "w")
	file:write(showTypeH().."\n")
	file:close()
end
if (arg[1] == "type.c") then
	file = io.open("type.c", "w")
	file:write(showTypeC().."\n")
	file:close()
end
if (arg[1] == "type.hs") then
	file = io.open("type.hs", "w")
	file:write(showTypeHs().."\n")
	file:close()
end
if (arg[1] == "type.lua") then
	file = io.open("type.lua", "w")
	file:write(showTypeLua().."\n")
	file:close()
end
