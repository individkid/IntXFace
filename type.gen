dofile("show.lua")

--HERE Enums
Goal = { -- File-tag for file.c
	"NewHub", -- open file
	"ThdHub",
	"CfgHub", -- set pid and forward
	"AppHub", -- set pid and forward
	"HubThd", -- lock write forwarded
	"AppThd", -- lock append forwarded
	"ThdThd", -- file change notify
	"HubCfg", -- identify file change
	"ThdErr", -- close and report
	"HubErr", -- report and exit
}
State = { -- Event-tag for line.c
	"Stock",
	"First",
	"Assign",
	"Bind",
	"Wave",
	"Timer",
	"Audio",
}
Flow = { -- Event-mod for line.c
	"Sched",
	"Back",
	"Peek",
	"Poke",
	"Store",
	"Load",
}
Request = { -- Center-mod for plane.c
	"SetReq", -- set memory
	"GetReq", -- get memory
	"GotReq", -- response to GetReq
	"UseReq", -- notice that matrix changed
	"FixReq", -- request to revert matrix and change plane
}
Memory = { -- Center-tag for plane.c
	"Trianglez", -- indices of vertices of facet
	"Numericz", -- distances of plane above selected base
	"Vertexz", -- intersection of backlinked planes
	"Swarmz", -- array of points around focal point
	"Texturez", -- memory for textures
	"Basisz", -- base for each dimension
	"Allmatz", -- whole view transformation
	"Fewmatz", -- matrix per set of planes
	"Onematz", -- single face transformation
	"Piercez", -- pierce point normal and valid
	"Slicez", -- plane or point index ranges
	"Stringz", -- keyboard comparison strings
	"Patternz", -- comparison regular expressions
	"Resultz", -- regular expression substrings
	"Machinez", -- state machine lines
	"Configurez", -- configure to value
}
Configure = { -- Center-elem for plane.c
	"TriangleSize", -- refers to corners
	"NumericSize", -- planes for corners
	"VertexSize", -- corners of frame
	"SubjectSize", -- per view matrix
	"ObjectSize", -- per polytope matrix
	"ElementSize", -- per plane matrix
	"SwarmSize", -- early warning system
	"TextureSize", -- how to decorate
	"BasisSize", -- cospace converters
	"SliceSize", -- ranges per draw
	"MachineSize", -- vending machine lines
	"RegisterLine", -- state of machine
	"RegisterNest", -- current level
	"RegisterXform", -- which matrix
	"RegisterMemory", -- which memory
	"RegisterIndex", -- which memory instance
	"RegisterHint", -- argument from graphics
	"RegisterDone", -- shaders running count
	"RegisterOpen", -- windows open count
	"CompareConsole", -- console string index
	"CompareString", -- which compare string
	"ComparePattern", -- which compare pattern
	"CompareNumber", -- string pattern count
	"CompareSize", -- string pattern result
	"CenterRequest", -- fields to from client
	"CenterMemory",
	"CenterSize",
	"CenterIndex",
	"CenterSelf",
	"CenterRmw",
	"ArgumentShader", -- pass to draw
	"ArgumentStart",
	"ArgumentStop",
	"ClosestLeft", -- search through pierce
	"ClosestBase",
	"ClosestNear",
	"ClosestFound",
	"UniformAll", -- which subject matrix
	"UniformOne", -- which element matrix
	"UniformLeft", -- pierce point horizontal
	"UniformBase", -- pierce pont vertical
	"UniformIndex", -- manipulate plane select
	"UniformSize", -- early warning points
	"UniformBasis", -- which cospace basis
	"WindowLeft", -- window initialization
	"WindowBase",
	"WindowWide",
	"WindowHigh",
	"CursorLeft", -- user input mouse
	"CursorBase",
	"CursorAngle",
	"CursorClick",
	"OriginLeft", -- starting cursor
	"OriginBase",
}
Transfer = { -- Machine-tag for plane.c
	"Read", -- read internal pipe
	"Write", -- write external pipe
	"Save", -- client, pierce, or info to configure
	"Force", -- machine to configure
	"Setup", -- configure to client
	"Alloc", -- configure to client
	"Echo", -- collect to client
	"Comp", -- change center to composition of optimization and cursor/fixed/mode
	"Pose", -- change center to towrite
	"Other", -- change center to maintain
	"Glitch", -- set maintain to center
	"Check", -- apply center to maintain and unapply to written
	"Stage", -- apply cursor/fixed/mode to towrite and change fixed for continuity
	"Apply", -- apply towrite to written and clear towrite
	"Accum", -- apply written to maintain and clear written
	"Share", -- dma to cpu or gpu
	"Draw", -- start shader
	"Jump", -- skip if true
	"Goto", -- jump if true
	"Nest", -- nest to level
	"Swap", -- exchange machine lines
}
Operation = { -- Expression-tag for plane.c
	"Fadd",
	"Iadd",
	"Fsub",
	"Isub",
	"Fmul",
	"Imul",
	"Fdiv",
	"Idiv",
	"Frem",
	"Irem",
	"Ftoi",
	"Itof",
	"Fval",
	"Ival",
	"Conf",
	"Side",
	"Drop",
	"Cond",
}
Transform = { -- Configure-cast for plane.c
	"Translate",
	"Rotate",
	"Scale",
	"Zoom",
}
Shader = {
	"Dipoint", -- display from triangles of points
	"Diplane", -- display from triangles of points from planes
	"Adpoint", -- find pierce points from triangles of points
	"Adplane", -- find pierce points from triangles of points from planes
	"Copoint", -- find planes from triangles of points
	"Coplane", -- find points from planes
	"Onpoint", -- fill triangle with plane shared by corners
	"Onplane", -- fill pierce with points on given plane
	"Depoint", -- copy points to pierces
	"Deplane", -- copy planes to pierces
}
Stage = { -- Configure-cast for plane.c
	"Corner",
	"Fragment",
}
Wait = { -- Configure-cast for plane.c
	"Open",
	"Close",
	"Start",
	"Stop",
}
Concur = { -- Configure-cast for plane.c
	"External",
	"Console",
	"Program",
	"Window",
	"Process",
}
Ture = { -- Sculpt-tag for space.c
	"Table",
	"Sides",
}
Stream = { -- Memx-cast for share.c
	"Encode", -- read string and write type
	"Decode", -- read type and write string
	"Insert", -- read twice and write second with first inserted
	"Extract", -- write extracted from read
	"Portion", -- read Data and write portion of Dat
	"Replace", -- read Data and Dat and replace portion
	"Unique", -- read several strings and write hole int
	"Permute", -- read several and write in different order
	"Constant", -- read several and write constant after them
	"Repeat", -- read several and write the last again after them
	"Delete", -- read several and write all but the last
	"Follow", -- read several and write from path after them
}
Logic = { -- Data-elem for datx.c
	"WrpJmp",
	"WrpYld",
	"RunJmp",
	"RunYld",
	"ClrVal",
	"ClrJmp",
	"ClrYld",
	"SkpVal",
	"SkpJmp",
	"SkpYld",
	"ImmJmp",
	"ImmYld",
	"SetJmp",
}
Process = { -- Argument-tag for show.c
	"Filez",
	"Holez",
	"Linez",
	"Planez",
	"Spacez",
	"Pagez",
	"Pipez",
	"Framez",
	"Wavez",
	"Tapez",
	"Phonez",
}
--HERE Constants
Initial = {
	{"Shader","Dipoint","Stage","Corner","Str","vertex_render"},
	{"Shader","Dipoint","Stage","Fragment","Str","fragment_render"},
	{"Shader","Diplane","Stage","Corner","Str","diplane_vertex"},
	{"Shader","Diplane","Stage","Fragment","Str","diplane_fragment"},
	{"Shader","Adpoint","Str","kernel_pierce"},
	{"Shader","Adplane","Str","adplane_compute"},
	{"Shader","Copoint","Str","copoint_compute"},
	{"Shader","Coplane","Str","coplane_compute"},
	{"Shader","Onpoint","Str","onpoint_compute"},
	{"Shader","Onplane","Str","onplane_compute"},
	{"Shader","Depoint","Str","depoint_compute"},
	{"Shader","Deplane","Str","deplane_compute"},
}
Bootstrap = {
	{"Int","0","Str","Center(req:Request(SetReq)mem:Memory(Configurez)siz:Int(4)idx:Int(0)slf:Int(0)rmw:Int(0)"..
		"cfg[0]:Configure(WindowWide)"..
		"cfg[1]:Configure(WindowHigh)"..
		"cfg[2]:Configure(MachineSize)"..
		"cfg[3]:Configure(RegisterOpen)"..
		"val[0]:Int(1024)"..
		"val[1]:Int(512)"..
		"val[2]:Int(1)"..
		"val[3]:Int(31)"..
	")"},
	{"Int","1","Str","Center(req:Request(SetReq)mem:Memory(Machinez)siz:Int(1)idx:Int(0)slf:Int(0)rmw:Int(0)"..
		"mch[0]:Machine(xfr:Transfer(Force)siz:Int(1)idx:Int(0)"..
			"cfg[0]:Configure(RegisterOpen)"..
			"val[0]:Int(0)"..
		")"..
	")"},
}
Execname = {
	{"Process","Filez","Str","./file"},
	{"Process","Holez","Str","./hole"},
	{"Process","Linez","Str","./line"},
	{"Process","Planez","Str","./plane"},
	{"Process","Spacez","Str","./space"},
	{"Process","Pagez","Str","./page"},
	{"Process","Pipez","Str","./pipe"},
	{"Process","Framez","Str","./frame"},
	{"Process","Wavez","Str","./wave"},
	{"Process","Tapez","Str","./tape"},
	{"Process","Phonez","Str","./phone"},
}
--HERE Structs
File = {
	{"act","Goal",{},{}},
	{"idx","Int",{["act"]={
		["NewHub"]=true,["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubCfg"]=true,
		["ThdErr"]=true
	}},{}}, -- identifier for file
	{"loc","New",{["act"]={
		["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,["ThdThd"]=true,
		["HubCfg"]=true
	}},{}}, -- location in file
	{"pid","New",{["act"]={
		["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,["ThdThd"]=true
	}},{}}, -- process id for fifo
	{"slf","Int",{["act"]={
		["HubCfg"]=true
	}},{}}, -- whether process id is self
	{"str","Str",{["act"]={
		["NewHub"]=true,["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,
		["HubCfg"]=true,
		["ThdErr"]=true,["HubErr"]=true
	}},{}}, -- file or field
}
Term0 = {
	{"cff","Num",{},{}},
}
Term1 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{1}},
}
Term2 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{2}},
}
Term3 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{3}},
}
Nomial = {
	{"num0","Int",{},{}},
	{"trm0","Term0",{},"num0"},
	{"num1","Int",{},{}},
	{"trm1","Term1",{},"num1"},
	{"num2","Int",{},{}},
	{"trm2","Term2",{},"num2"},
	{"num3","Int",{},{}},
	{"trm3","Term3",{},"num3"},
}
Ratio = {
	{"num","Nomial",{},{}},
	{"den","Nomial",{},{}},
}
Event = { -- for line process
	{"tag","State",{},{}},
	{"idx","Int",{},{}},
	{"oth","Int",{},{}},
	{"key","Num",{},{}},
	{"val","Num",{},{}},
    {"upd","Ratio",{["tag"]={["Stock"]=true}},{}},
    {"dly","Ratio",{["tag"]={["Stock"]=true}},{}},
    {"sch","Ratio",{["tag"]={["Stock"]=true}},{}},
	{"flw","Flow",{["tag"]={["Bind"]=true}},{}},
	{"siz","Int",{["tag"]={["Wave"]=true}},{}},
	{"buf","Num",{["tag"]={["Wave"]=true}},"siz"},
	{"num","Int",{["tag"]={["Timer"]=true}},{}},
	{"tot","Int",{["tag"]={["Timer"]=true}},{}},
	{"ids","Int",{["tag"]={["Timer"]=true}},"num"},
	{"req","Int",{["tag"]={["Timer"]=true}},"num"},
	{"rsp","Num",{["tag"]={["Timer"]=true}},"tot"},
	{"wrp","Num",{["tag"]={["Audio"]=true}},{}},
	{"gap","Int",{["tag"]={["Audio"]=true}},{}},
	{"cdt","Int",{["tag"]={["Audio"]=true}},{}},
	{"len","Int",{["tag"]={["Audio"]=true}},{}},
	{"enb","Int",{["tag"]={["Audio"]=true}},{}},
}
Uniform = {
	{"all","Int",{},{}}, -- which subject to use
	{"one","Int",{},{}}, -- which element to use
	{"lon","Int",{},{}}, -- horizontal axis of cursor
	{"lat","Int",{},{}}, -- vertical axis of cursor

	{"lft","Int",{},{}}, -- horizontal axis of window
	{"bas","Int",{},{}}, -- vertical axis of window
	{"wdt","Int",{},{}}, -- horizontal size of window
	{"hdt","Int",{},{}}, -- vertical size of window

	{"idx","Int",{},{}}, -- which plane to apply one matrix to
	{"siz","Int",{},{}}, -- how many swarm points there are
	{"csp","Int",{},{}}, -- which basis to use
	{"tsz","Int",{},{}}, -- size of trinagle buffer

	{"nsz","Int",{},{}}, -- size of numeric buffer
	{"vsz","Int",{},{}}, -- size of vertex buffer
	{"asz","Int",{},{}}, -- size of subject buffer
	{"fsz","Int",{},{}}, -- size of object buffer

	{"osz","Int",{},{}}, -- size of element buffer
	{"ssz","Int",{},{}}, -- size of swarm buffer
	{"xsz","Int",{},{}}, -- size of texture buffer
	{"bsz","Int",{},{}}, -- size of basis buffer
}
-- TODO Int32 type
Triangle = {
	{"vtx","Int32",{},{4}}, -- points of triangle
	{"num","Int32",{},{}}, -- plane of points
	{"tex","Int32",{},{}}, -- texture of triangle
	{"pol","Int32",{},{}}, -- polytope triangle is in
	{"pad","Int32",{},{}},
}
Numeric = {
	{"vec","Old",{},{4}}, -- distances above basis
	{"bas","Int32",{},{}}, -- basis selector
	{"pad","Int32",{},{3}},
}
Vertex = {
	{"vec","Old",{},{4}}, -- intersection of planes
	{"ref","Int32",{},{3}}, -- backreference to planes
	{"pad","Int32",{},{}},
}
Pierce = {
	{"fix","Old",{},{4}},
	{"nml","Old",{},{4}},
	{"vld","Int32",{},{}},
	{"idx","Int32",{},{}},
	{"pad","Int32",{},{2}},
}
Vector = {
	{"vec","Old",{},{4}},
}
Matrix = {
	{"mat","Old",{},{16}},
}
Basis = {
	{"mat","Old",{},{36}},
}
Slice = {
	{"idx","Int",{},{}},
	{"siz","Int",{},{}},
}
Expression = {
	{"opr","Operation",{},{}},
	{"cfg","Configure",{["opr"]={["Conf"]=true,["Side"]=true}},{}},
	{"ivl","Int",{["opr"]={["Ival"]=true}},{}},
	{"fvl","Old",{["opr"]={["Fval"]=true}},{}},
	{"siz","Int",{},{}},
	{"exp","Expression",{},"siz"},
}
Machine = {
	{"xfr","Transfer",{},{}},
	{"siz","Int",{},{}},
	{"idx","Int",{},{}},
	{"cfg","Configure",{["xfr"]={["Force"]=true,["Setup"]=true,["Save"]=true}},"siz"},
	{"val","Int",{["xfr"]={["Force"]=true,["Setup"]=true}},"siz"},
	{"oth","Int",{["xfr"]={["Swap"]=true}},{}},
	{"exp","Expression",{["xfr"]={["Jump"]=true,["Goto"]=true}},1},
}
Center = {
	{"req","Request",{},{}},
	{"mem","Memory",{},{}},
	{"siz","Int",{},{}},
	{"idx","Int",{},{}},
	{"slf","Int",{},{}},
	{"rmw","Int",{},{}},
	{"tri","Triangle",{["mem"]={["Trianglez"]=true}},"siz"},
	{"num","Numeric",{["mem"]={["Numericz"]=true}},"siz"},
	{"vtx","Vertex",{["mem"]={["Vertexz"]=true}},"siz"},
	{"all","Matrix",{["mem"]={["Allmatz"]=true}},"siz"},
	{"few","Matrix",{["mem"]={["Fewmatz"]=true}},"siz"},
	{"one","Matrix",{["mem"]={["Onematz"]=true}},"siz"},
	{"swa","Vector",{["mem"]={["Swarmz"]=true}},"siz"},
	{"tex","Vector",{["mem"]={["Texturez"]=true}},"siz"},
	{"bas","Basis",{["mem"]={["Basisz"]=true}},"siz"},
	{"pie","Pierce",{["mem"]={["Piercez"]=true}},"siz"},
	{"rng","Slice",{["mem"]={["Slicez"]=true}},"siz"},
	{"str","Str",{["mem"]={["Stringz"]=true,["Patternz"]=true,["Resultz"]=true}},"siz"},
	{"mch","Machine",{["mem"]={["Machinez"]=true}},"siz"},
	{"cfg","Configure",{["mem"]={["Configurez"]=true}},"siz"},
	{"val","Int",{["mem"]={["Configurez"]=true}},"siz"},
}
Sculpt = {
	{"cfg","Ture",{},{}},
}
Data = {
	{"siz","Int",{},{}},
	{"lim","Int",{},"siz"},
	{"jmp","Int",{},"siz"},
	{"loc","Int",{},"siz"},
	{"len","Int",{},{}},
	{"opc","Logic",{},"len"},
	{"dat","Dat",{},{}},
}
Argument = {
	{"typ","Process",{},{}},
	{"inp","Int",{},{}},
	{"out","Int",{},{}},
	{"idx","Int",{},{}},
	{"str","Str",{["typ"]={["Holez"]=true}},{}},
}
--HERE
Enums,Enumz = listHere("Enums","type.gen")
Constants,Constantz = listHere("Constants","type.gen")
Structs,Structz = listHere("Structs","type.gen")
function showTypeC()
	local result = ""
	result = result.."#include \"face.h\"\n"
	result = result.."#include \"type.h\"\n"
	result = result.."#include <stdlib.h>\n"
	result = result.."#include <string.h>\n"
	result = result.."#include <stdio.h>\n"
	result = result.."#include <unistd.h>\n"
	result = result.."#include <sys/errno.h>\n"
	result = result..showCallC().."\n"
	result = result.."int wrapExec(struct Argument *arg, const char *fork, const char *exec) {\n"
	result = result..showIndent(1).."int idx = openFork();\n"
	result = result..showIndent(1).."if (idx < 0) return -1;\n"
	result = result..showIndent(1).."if (openCheck(idx) >= 0) {\n"
	result = result..showIndent(2).."char *str = 0; int len = 0;\n"
	result = result..showIndent(2).."arg->inp=openRdfd(idx); arg->out=openWrfd(idx);\n"
	result = result..showIndent(2).."showArgument(arg,&str,&len);\n"
	result = result..showIndent(2).."openExec(exec,str); fprintf(stderr,\"%s: cannot execute file: %s\\n\",fork,exec); ERROR();}\n"
	result = result..showIndent(1).."return idx;}\n"
	result = result.."int wrapType(enum Process typ, const char *fork, const char *exec) {\n"
	result = result..showIndent(1).."struct Argument arg = {0};\n"
	result = result..showIndent(1).."arg.typ = typ;\n"
	result = result..showIndent(1).."return wrapExec(&arg,fork,exec);}\n"
	result = result.."int wrapInit(struct Argument *arg, const char *str) {\n"
	result = result..showIndent(1).."int len = 0;\n"
	result = result..showIndent(1).."if (!hideArgument(arg,str,&len)) return -1;\n"
	result = result..showIndent(1).."arg->idx = rdwrInit(arg->inp,arg->out);\n"
	result = result..showIndent(1).."return 0;}\n"
	result = result.."int wrapIdent(enum Process typ, const char *str) {\n"
	result = result..showIndent(1).."struct Argument arg = {0};\n"
	result = result..showIndent(1).."if (wrapInit(&arg,str) < 0 || arg.typ != typ) return -1;\n"
	result = result..showIndent(1).."return arg.idx;}"
	return result
end
function showTypeH()
	local result = ""
	result = result.."#include \"proto.h\"\n"
	result = result..showCallH().."\n"
	result = result.."int wrapExec(struct Argument *arg, const char *fork, const char *exec);\n"
	result = result.."int wrapType(enum Process typ, const char *fork, const char *exec);\n"
	result = result.."int wrapInit(struct Argument *arg, const char *str);"
	result = result.."int wrapIdent(enum Process typ, const char *str);\n"
	return result
end
function showTypeHs()
	local result = ""
	result = result.."module Type where\n"
	result = result.."--\n"
	result = result.."import Face\n"
	result = result.."import System.Environment\n"
	result = result.."import System.IO\n"
	result = result.."import Data.IORef\n"
	result = result.."import Data.Int\n"
	result = result.."import Foreign.C.Types\n"
	result = result.."--\n"
	result = result.."type Dat = [CChar]\n"
	result = result..showCallHs().."\n"
	-- foreign import ccall "openFork" openForkC :: IO CInt
	-- foreign import ccall "openCheck" openCheckC :: CInt -> IO CInt
	-- foreign import ccall "openRdfd" openRdfdC :: CInt -> IO CInt
	-- foreign import ccall "openWrfd" openWrfdC :: CInt -> IO CInt
	-- foreign import ccall "openExec" openExecC :: CString -> CString -> IO CInt
	-- foreign import ccall "rdwrInit" rdwrInitC :: CInt -> CInt -> IO CInt
	-- showArgument :: Argument -> IORef String -> IO ()
	-- setArgumentCinp :: Argument -> Int -> Argument
	-- getArgumentCinp :: Argument -> Int
	-- result = result.."int wrapExec(struct Argument *arg, const char *fork, const char *exec) {\n"
	-- result = result..showIndent(1).."int idx = openFork();\n"
	-- result = result..showIndent(1).."if (idx < 0) return -1;\n"
	-- result = result..showIndent(1).."if (openCheck(idx) >= 0) {\n"
	-- result = result..showIndent(2).."char *str = 0; int len = 0;\n"
	-- result = result..showIndent(2).."arg->inp=openRdfd(idx); arg->out=openWrfd(idx);\n"
	-- result = result..showIndent(2).."showArgument(arg,&str,&len);\n"
	-- result = result..showIndent(2).."openExec(exec,str); fprintf(stderr,\"%s: cannot execute file: %s\\n\",fork,exec); ERROR();}\n"
	-- result = result..showIndent(1).."return idx;}\n"
	result = result.."wrapExec :: Argument -> String -> String -> IO (Maybe Int)\n"
	result = result.."wrapExec arg fork exec = do\n"
	result = result..showIndent(1).."idx <- openFork\n"
	result = result..showIndent(1).."if idx < 0 then return Nothing else do\n"
	result = result..showIndent(2).."vld <- openCheck idx\n"
	result = result..showIndent(2).."if vld < 0 then return (Just idx) else do\n"
	result = result..showIndent(3).."inp <- openRdfd idx\n"
	result = result..showIndent(3).."out <- openWrfd idx\n"
	result = result..showIndent(3).."ptr <- newIORef \"\"\n"
	result = result..showIndent(3).."showArgument (setArgumentCinp (setArgumentCout arg out) inp) ptr\n"
	result = result..showIndent(3).."str <- readIORef ptr\n"
	result = result..showIndent(3).."openExec exec str\n"
	result = result..showIndent(3).."hPutStrLn stderr (fork ++ \": cannot execute file: \" ++ exec)\n"
	result = result..showIndent(3).."callExit (negate 1)\n"
	result = result..showIndent(3).."return Nothing\n"
	-- result = result.."int wrapType(enum Process typ, const char *fork, const char *exec) {\n"
	-- result = result..showIndent(1).."struct Argument arg = {0};\n"
	-- result = result..showIndent(1).."arg.typ = typ;\n"
	-- result = result..showIndent(1).."return wrapExec(&arg,fork,exec);}\n"
	result = result.."wrapType :: Process -> String -> String -> IO (Maybe Int)\n"
	result = result.."wrapType typ fork exec = wrapExec (Argument (ArgumentA1 typ 0 0 0) ArgumentA5Bs) fork exec\n"
	-- result = result.."int wrapInit(struct Argument *arg, const char *str) {\n"
	-- result = result..showIndent(1).."int len = 0;\n"
	-- result = result..showIndent(1).."if (!hideArgument(arg,str,&len)) return -1;\n"
	-- result = result..showIndent(1).."arg->idx = rdwrInit(arg->inp,arg->out);\n"
	-- result = result..showIndent(1).."return 0;}\n"
	result = result.."wrapInitF :: Maybe Argument -> IO (Maybe Argument)\n"
	result = result.."wrapInitF Nothing = return Nothing\n"
	result = result.."wrapInitF (Just arg) = do\n"
	result = result..showIndent(1).."idx <- rdwrInit (getArgumentCinp arg) (getArgumentCout arg)\n"
	result = result..showIndent(1).."return (Just (setArgumentCidx arg idx))\n"
	result = result.."wrapInit :: String -> IO (Maybe Argument)\n"
	result = result.."wrapInit str = newRefStr str >>= hideArgument >>= wrapInitF\n"
	-- result = result.."int wrapIdent(enum Process typ, const char *str) {\n"
	-- result = result..showIndent(1).."struct Argument arg = {0};\n"
	-- result = result..showIndent(1).."if (wrapInit(&arg,str) < 0 || arg.typ != typ) return -1;\n"
	-- result = result..showIndent(1).."return arg.idx;}"
	result = result.."wrapIdentF :: Process -> Maybe Argument -> IO (Maybe Int)\n"
	result = result.."wrapIdentF _ Nothing = return Nothing\n"
	result = result.."wrapIdentF typ (Just arg) = if typ /= (getArgumentCtyp arg) then\n"
	result = result..showIndent(1).."return Nothing else\n"
	result = result..showIndent(1).."return (Just (getArgumentCidx arg))\n"
	result = result.."wrapIdent :: Process -> String -> IO (Maybe Int)\n"
	result = result.."wrapIdent typ str = wrapInit str >>= wrapIdentF typ\n"
	return result
end
function showTypeLua()
	local result = ""
	result = result.."require \"face\"\n"
	result = result.."--\n"
	result = result..showCallLua().."\n"
	result = result.."function wrapExec(arg,fork,exec)\n"
	result = result..showIndent(1).."idx = openFork()\n"
	result = result..showIndent(1).."if (idx < 0) then return -1 end\n"
	result = result..showIndent(1).."if (openCheck(idx) >= 0) then\n"
	result = result..showIndent(1).."arg[\"inp\"]=openRdfd(idx); arg[\"out\"]=openWrfd(idx); arg[\"idx\"]=-1\n"
	result = result..showIndent(1).."if (arg[\"typ\"] == nil) then arg[\"typ\"] = \"Processs\"end\n"
	result = result..showIndent(2).."str = showArgument(arg,\"\")\n"
	result = result..showIndent(2).."openExec(exec,str); io.stderr:write(fork..\": cannot execute file: \"..exec..\"\\n\"); os.exit(-1)\n"
	result = result..showIndent(1).."end\n"
	result = result..showIndent(1).."return idx\n"
	result = result.."end\n"
	result = result.."function wrapType(typ,fork,exec)\n"
	result = result..showIndent(1).."arg[\"typ\"] = typ\n"
	result = result..showIndent(1).."return wrapExec(arg,fork,exec)\n"
	result = result.."end\n"
	result = result.."function wrapInit(str)\n"
	result = result..showIndent(1).."arg,str = hideArgument(str)\n"
	result = result..showIndent(1).."if (arg == nil) then return nil end\n"
	result = result..showIndent(1).."arg[\"idx\"] = rdwrInit(arg[\"inp\"],arg[\"out\"])\n"
	result = result..showIndent(1).."return arg\n"
	result = result.."end\n"
	result = result.."function wrapIdent(typ,str)\n"
	result = result..showIndent(1).."arg = wrapInit(str)\n"
	result = result..showIndent(1).."if (arg == nil) or not (arg[\"typ\"] == typ) then return -1 end\n"
	result = result..showIndent(1).."return arg[\"idx\"]\n"
	result = result.."end"
	return result
end
if (arg[1] == "type.dep") then
	file = io.open("type.dep", "w")
	file:close()
end
if (arg[1] == "type.h") then
	file = io.open("type.h", "w")
	file:write(showTypeH().."\n")
	file:close()
end
if (arg[1] == "type.c") then
	file = io.open("type.c", "w")
	file:write(showTypeC().."\n")
	file:close()
end
if (arg[1] == "type.hs") then
	file = io.open("type.hs", "w")
	file:write(showTypeHs().."\n")
	file:close()
end
if (arg[1] == "type.lua") then
	file = io.open("type.lua", "w")
	file:write(showTypeLua().."\n")
	file:close()
end
