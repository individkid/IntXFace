dofile("show.lua")

--HERE Enums
Goal = {
	"NewHub", -- open file
	"ThdHub",
	"CfgHub", -- set pid and forward
	"AppHub", -- set pid and forward
	"HubThd", -- lock write forwarded
	"AppThd", -- lock append forwarded
	"ThdThd", -- file change notify
	"HubCfg", -- identify file change
	"ThdErr", -- close and report
	"HubErr", -- report and exit
}
State = {
	"Stock",
	"First",
	"Assign",
	"Bind",
	"Wave",
	"Timer",
	"Audio",
}
Flow = {
	"Sched",
	"Back",
	"Peek",
	"Poke",
	"Store",
	"Load",
}
Memory = {
	"Trianglez", -- indices of vertices of facet
	"Numericz", -- distances of plane above selected base
	"Vertexz", -- intersection of backlinked planes
	"Swarmz", -- array of points around focal point
	"Texturez", -- memory for textures
	"Basisz", -- base for each dimension
	"Allmatz", --c; whole view transformation
	"Fewmatz", --c; matrix per set of planes
	"Onematz", --c; single face transformation
	"Piercez", --c; pierce point normal and valid
	"Slicez", -- plane or point index ranges
	"Stringz", -- keyboard comparison strings
	"Machinez", -- state machine lines
	"Configurez", --c,a; configure to value
}
Configure = {
	"TriangleSize", -- written refers to corners
	"TriangleBase", --
	"NumericSize", -- written planes for corners
	"NumericBase", --
	"VertexSize", -- written corners of frame
	"VertexBase", --
	"SubjectSize", -- written per view matrix
	"SubjectBase", --
	"ObjectSize", -- written per polytope matrix
	"ObjectBase", --
	"ElementSize", -- written per plane matrix
	"ElementBase", --
	"SwarmSize", -- written early warning system
	"SwarmBase", --
	"TextureSize", -- written how to decorate
	"TextureBase", --
	"BasisSize", -- written cospace converters
	"BasisBase", --
	"PierceSize", -- written pierce points
	"PierceBase", --
	"SliceSize", -- written ranges per draw
	"SliceBase", --
	"MachineSize", -- written vending machine lines
	"UniformAll", -- which subject matrix
	"UniformOne", -- which element matrix
	"UniformLeft", -- pierce point horizontal
	"UniformBase", -- pierce pont vertical
	"UniformLong", -- focal length
	"UniformIndex", -- manipulate plane select
	"UniformBasis", -- which cospace basis
	"UniformSize", -- early warning points
	"ArgumentMicro", -- pass to draw
	"ArgumentBase", --
	"ArgumentLimit", --
	"RegisterPrompt", -- prompt string index
	"RegisterResponse", -- response string index
	"RegisterMemory", -- which memory
	"RegisterIndex", -- which instance
	"RegisterTool", -- which function
	"RegisterChange", -- which changed
	"RegisterFixed", -- which fixed
	"RegisterFind", -- which pierce
	"RegisterDone", -- shaders running count
	"RegisterOpen", -- thread running mask
	"ResultLine", -- state of machine
	"ResultHint", -- argument from graphics
	"ResultType", -- type of eval result
	"ResultSize", -- result of append to strings
	"OriginLeft", -- starting cursor
	"OriginBase", --
	"OriginNear", --
	"OriginAngle", --
	"ClosestValid", -- search through pierce
	"ClosestFound", --
	"ClosestLeft", --
	"ClosestBase", --
	"ClosestNear", --
	"NormalLeft", --
	"NormalBase", --
	"NormalNear", --
	"WindowLeft", -- window initialization
	"WindowBase", --
	"WindowWide", --
	"WindowHigh", --
	"WindowNear", --
	"WindowFar", --
	"WindowLength", --
	"CursorLeft", -- user input mouse
	"CursorBase", --
	"CursorNear", --
	"CursorAngle", --
	"CursorClick", --
	"CenterMemory", -- fields to from client
	"CenterSize", --
	"CenterIndex", --
	"CenterSelf", --
}
Transfer = {
	"Read", -- read internal pipe
	"Write", -- write external pipe
	"Stage", -- center fields, pierce, or info to configure
	"Force", -- machine to configure
	"Comp", -- composition to center
	"Pose", -- towrite to center
	"Other", -- maintain to center
	"Glitch", -- center to maintain
	"Check", -- apply center to maintain
	"Local", -- apply cursor/fixed/mode
	"Apply", -- apply towrite to written
	"Accum", -- apply written to maintain
	"Proj", -- perspective matrix
	"Copy", -- dma to cpu or gpu
	"Draw", -- start shader
	"Jump", -- skip if true
	"Goto", -- jump if true
	"Nest", -- nest to level
	"Eval", -- call datxEval
	"Echo", -- copy result to global
	"Fill", -- copy instance to global
}
Change = {
	"Slide",
	"Rotate",
	"Scale",
}
Fixed = {
	"Ortho",
	"Focal",
	"Normal",
}
Tool = {
	"Mouse",
	"Roller",
}
Micro = {
	"Dipoint", -- display from triangles of points
	"Diplane", -- display from triangles of points from planes
	"Adpoint", -- find pierce points from triangles of points
	"Adplane", -- find pierce points from triangles of points from planes
	"Copoint", -- find planes from triangles of points
	"Coplane", -- find points from planes
	"Onpoint", -- fill triangle with plane shared by corners
	"Onplane", -- fill pierce with points on given plane
	"Depoint", -- copy points to pierces
	"Deplane", -- copy planes to pierces
}
Code = {
	"Corner",
	"Fragment",
}
Wait = {
	"Start",
	"Stop",
	"Done",
}
Proc = {
	"External",
	"Console",
	"Window",
	"Graphics",
	"Process",
}
Struc = {
	"Table",
	"Sides",
}
Stream = {
	"Fanout", -- write to named pipes; one input, multiple outputs
	"Combine", -- buffer(s) to pipe; no input, multiple outputs
	"Buffer", -- name a buffer; one input, no output
	"Execute", -- name a filter; typ is input type, for pipe named by str in successor, with output typ in successor
}
Logic = {
	"WrpJmp",
	"WrpYld",
	"RunJmp",
	"RunYld",
	"ClrVal",
	"ClrJmp",
	"ClrYld",
	"SkpVal",
	"SkpJmp",
	"SkpYld",
	"ImmJmp",
	"ImmYld",
	"SetJmp",
}
Operate = {
	"AddOp",
	"SubOp",
	"MulOp",
	"DivOp",
	"RemOp",
	"PthOp", -- if else compare
	"EndOp", -- map str to exp
	"TotOp", -- cast to type
	"GetOp", -- value from callback
	"SetOp", -- callback with value
	"ValOp", -- value from lookup
	"SavOp", -- value for lookup
	"InsOp", -- fields to struct
	"ExtOp", -- fields from struct
	"PrmOp", -- permute list
	"CatOp", -- concatenate lists
	"HetOp", -- built in list
	"HomOp", -- built in list
	"ImmOp", -- built in value
	"IntOp", -- ImmOp sugar
	"StrOp", -- ImmOp sugar
	"CfgOp", -- ImmOp sugar
	"MemOp", -- ImmOp sugar
	"UnqOp", -- magic number
	"EmbOp", -- script embed
	"DatOp", -- stream data
}
Compare = {
	-- Less Equal More
	-- Open Closed
	"LOCmp",
	"LCCmp",
	"EOCmp",
	"ECCmp",
	"MOCmp",
	"MCCmp",
}
Action = {
	"NegAct",
	"ClrAct",
	"IncAct",
	"StrAct",
	"SubAct",
}
Process = {
	"Filez",
	"Holez",
	"Linez",
	"Planez",
	"Spacez",
	"Pagez",
	"Pipez",
	"Framez",
	"Wavez",
	"Tapez",
	"Phonez",
}
--HERE Constants
Initial = {
	{"Micro","Dipoint","Code","Corner","Str","vertex_render"},
	{"Micro","Dipoint","Code","Fragment","Str","fragment_render"},
	{"Micro","Diplane","Code","Corner","Str","diplane_vertex"},
	{"Micro","Diplane","Code","Fragment","Str","diplane_fragment"},
	{"Micro","Adpoint","Str","kernel_pierce"},
	{"Micro","Adplane","Str","adplane_compute"},
	{"Micro","Copoint","Str","copoint_compute"},
	{"Micro","Coplane","Str","coplane_compute"},
	{"Micro","Onpoint","Str","onpoint_compute"},
	{"Micro","Onplane","Str","onplane_compute"},
	{"Micro","Depoint","Str","depoint_compute"},
	{"Micro","Deplane","Str","deplane_compute"},
}
Bootstrap = {
	{"Int","0","Str","Machine(xfr:Transfer(Force)siz:Int(8)"..
		"cfg[0]:Configure(WindowWide)"..
		"cfg[1]:Configure(WindowHigh)"..
		"cfg[2]:Configure(ArgumentMicro)"..
		"cfg[3]:Configure(MachineSize)"..
		"cfg[4]:Configure(RegisterOpen)"..
		"cfg[5]:Configure(RegisterOpen)"..
		"cfg[6]:Configure(RegisterOpen)"..
		"cfg[7]:Configure(RegisterOpen)"..
		"val[0]:Int(1024)"..
		"val[1]:Int(512)"..
		"val[2]:Int(%(return castMicro(\"Adpoint\")))"..
		"val[3]:Int(21)"..
		"val[4]:Int(1)"..
		"val[5]:Int(3)"..
		"val[6]:Int(15)"..
		"val[7]:Int(31)"..
	")"},
	{"Int","1","Str","Machine(xfr:Transfer(Eval)siz:Int(0)"..
	"exp[0]:Express(opr:Operate(SavOp)kys:Str(Changed)"..
		"sav[0]:Express(opr:Operate(IntOp)ivl:Int(0))"..
	"))"},
	{"Int","2","Str","Machine(xfr:Transfer(Eval)siz:Int(0)"..
	"exp[0]:Express(opr:Operate(ImmOp)val[0]:Generic(tag:Tag(CenterTag)"..
	"center[0]:Center(mem:Memory(Machinez)siz:Int(21)idx:Int(0)slf:Int(0)"..
		"mch[0]:Machine(xfr:Transfer(Nest)siz:Int(0)lvl:Int(5))"..
		"mch[1]:Machine(xfr:Transfer(Jump)siz:Int(1)exp[0]:Express(opr:Operate(EndOp)end[0]:LeafExp("..
			"siz:Int(4)pat[0]:Express(opr:Operate(PthOp)pth[0]:BranchExp(siz:Int(5)"..
				"lft[0]:Express(opr:Operate(GetOp)cfg:Configure(ResultHint))"..
				"lft[1]:Express(opr:Operate(GetOp)cfg:Configure(ResultHint))"..
				"lft[2]:Express(opr:Operate(GetOp)cfg:Configure(ResultHint))"..
				"lft[3]:Express(opr:Operate(ValOp)key:Str(Changed))"..
				"lft[4]:Express(opr:Operate(ValOp)key:Str(Changed))"..
				"rgt[0]:Express(opr:Operate(CfgOp)cvl:Configure(CenterMemory))"..
				"rgt[1]:Express(opr:Operate(CfgOp)cvl:Configure(ResultHint))"..
				"rgt[2]:Express(opr:Operate(GetOp)cfg:Configure(ResultHint))"..
				"rgt[3]:Express(opr:Operate(IntOp)ivl:Int(1))"..
				"rgt[4]:Express(opr:Operate(ValOp)key:Str(Changed))"..
				"cmp[0]:Compare(ECCmp)"..
				"cmp[1]:Compare(ECCmp)"..
				"cmp[2]:Compare(ECCmp)"..
				"cmp[3]:Compare(ECCmp)"..
				"cmp[4]:Compare(ECCmp)"..
				"str[0]:Str(MatchRead)"..
				"str[1]:Str(MatchDraw)"..
				"str[2]:Str(Mismatch)"..
				"str[3]:Str(MatchDrawChanged)"..
				"str[4]:Str(MatchDrawUnchanged)))"..
			"exp[0]:Express(opr:Operate(IntOp)ivl:Int(2))"..
			"exp[1]:Express(opr:Operate(IntOp)ivl:Int(1))"..
			"exp[2]:Express(opr:Operate(IntOp)ivl:Int(0))"..
			"exp[3]:Express(opr:Operate(IntOp)ivl:Int(0))"..
			"str[0]:Str(MatchRead)"..
			"str[1]:Str(MatchDrawChanged)"..
			"str[2]:Str(MatchDrawUnchanged)"..
			"str[3]:Str(Mismatch))))"..
		"mch[2]:Machine(xfr:Transfer(Nest)siz:Int(0)lvl:Int(-1))".. -- MatchDrawChanged
		-- Draw, and remember that not Changed
		"mch[3]:Machine(xfr:Transfer(Draw)siz:Int(0))"..
		"mch[4]:Machine(xfr:Transfer(Eval)siz:Int(0)exp[0]:Express("..
			"opr:Operate(SavOp)kys:Str(Changed)"..
			"sav[0]:Express(opr:Operate(IntOp)ivl:Int(0))))"..
		"mch[5]:Machine(xfr:Transfer(Jump)siz:Int(1)exp[0]:Express(opr:Operate(IntOp)ivl:Int(-1)))"..
		"mch[6]:Machine(xfr:Transfer(Nest)siz:Int(0)lvl:Int(-1))".. -- MatchRead
		-- Read center, Stage center fields, and compare fields staged to Configure
		"mch[7]:Machine(xfr:Transfer(Read)siz:Int(0))"..
		"mch[8]:Machine(xfr:Transfer(Stage)siz:Int(3)"..
			"sav[0]:Configure(RegisterMemory)"..
			"sav[1]:Configure(RegisterIndex)"..
			"sav[2]:Configure(CenterSize))"..
		"mch[9]:Machine(xfr:Transfer(Jump)siz:Int(1)exp[0]:Express(opr:Operate(EndOp)end[0]:LeafExp("..
			"siz:Int(3)pat[0]:Express(opr:Operate(PthOp)pth[0]:BranchExp(siz:Int(4)"..
				"lft[0]:Express(opr:Operate(GetOp)cfg:Configure(CenterSize))"..
				"lft[1]:Express(opr:Operate(GetOp)cfg:Configure(CenterSize))"..
				"lft[2]:Express(opr:Operate(GetOp)cfg:Configure(RegisterMemory))"..
				"lft[3]:Express(opr:Operate(GetOp)cfg:Configure(RegisterMemory))"..
				"rgt[0]:Express(opr:Operate(IntOp)ivl:Int(0))"..
				"rgt[1]:Express(opr:Operate(GetOp)cfg:Configure(CenterSize))"..
				"rgt[2]:Express(opr:Operate(MemOp)mvl:Memory(Piercez))"..
				"rgt[3]:Express(opr:Operate(GetOp)cfg:Configure(RegisterMemory))"..
				"cmp[0]:Compare(ECCmp)"..
				"cmp[1]:Compare(ECCmp)"..
				"cmp[2]:Compare(ECCmp)"..
				"cmp[3]:Compare(ECCmp)"..
				"str[0]:Str(MatchGet)"..
				"str[1]:Str(MatchSet)"..
				"str[2]:Str(MatchGetPierce)"..
				"str[3]:Str(MatchGetNone)))"..
			"exp[0]:Express(opr:Operate(IntOp)ivl:Int(1))"..
			"exp[1]:Express(opr:Operate(IntOp)ivl:Int(2))"..
			"exp[2]:Express(opr:Operate(IntOp)ivl:Int(-1))"..
			"str[0]:Str(MatchSet)"..
			"str[1]:Str(MatchGetPierce)"..
			"str[2]:Str(MatchGetNone))))"..
		"mch[10]:Machine(xfr:Transfer(Nest)siz:Int(0)lvl:Int(-1))".. -- MatchSet
		-- Copy center to cpu and gpu, and remember that Changed
		"mch[11]:Machine(xfr:Transfer(Copy)siz:Int(0))"..
		"mch[12]:Machine(xfr:Transfer(Eval)siz:Int(0)exp[0]:Express("..
			"opr:Operate(SavOp)kys:Str(Changed)"..
			"sav[0]:Express(opr:Operate(IntOp)ivl:Int(1))))"..
		"mch[13]:Machine(xfr:Transfer(Jump)siz:Int(1)exp[0]:Express(opr:Operate(IntOp)ivl:Int(-1)))"..
		"mch[14]:Machine(xfr:Transfer(Nest)siz:Int(0)lvl:Int(-1))".. -- MatchGetPierce
		-- Eval and Echo singleton Pierce to center, Fill and Write center
		"mch[15]:Machine(xfr:Transfer(Eval)siz:Int(0)exp[0]:Express(opr:Operate(InsOp)"..
			"ins[0]:Express(opr:Operate(ImmOp)val[0]:Generic(tag:Tag(CenterTag)center[0]:Center("..
				"mem:Memory(Piercez)siz:Int(1)idx:Int(0)slf:Int(0)pie[0]:Pierce("..
				"fix[0]:Old(0)fix[1]:Old(0)fix[2]:Old(0)fix[3]:Old(0)"..
				"nml[0]:Old(0)nml[1]:Old(0)nml[2]:Old(0)nml[3]:Old(0)"..
				"vld:Int32(0)idx:Int32(0)pad[0]:Int32(0)pad[1]:Int32(0)))))".. -- Express struct
			"ins[1]:Express(opr:Operate(HetOp)siz:Int(1)exp[0]:Express(opr:Operate(TotOp)typ:Str(Int32)"..
				"tot[0]:Express(opr:Operate(GetOp)cfg:Configure(RegisterIndex))))".. -- Hetgen field values
			"ins[2]:Express(opr:Operate(HomOp)siz:Int(1)exp[0]:Express(opr:Operate(StrOp)svl:Str(idx)))".. -- Homgen Str field names
			"ins[3]:Express(opr:Operate(HomOp)siz:Int(1)exp[0]:Express(opr:Operate(IntOp)ivl:Int(0)))))".. -- Homgen Int field indices
		"mch[16]:Machine(xfr:Transfer(Echo)siz:Int(0))"..
		"mch[17]:Machine(xfr:Transfer(Fill)siz:Int(0))"..
		"mch[18]:Machine(xfr:Transfer(Write)siz:Int(0))"..
		"mch[19]:Machine(xfr:Transfer(Jump)siz:Int(1)exp[0]:Express(opr:Operate(IntOp)ivl:Int(-1)))"..
		"mch[20]:Machine(xfr:Transfer(Nest)siz:Int(0)lvl:Int(-1))))))"},
	{"Int","3","Str","Machine(xfr:Transfer(Echo)siz:Int(0))"},
	{"Int","4","Str","Machine(xfr:Transfer(Copy)siz:Int(0))"},
	{"Int","5","Str","Machine(xfr:Transfer(Goto)siz:Int(0)exp[0]:Express(opr:Operate(IntOp)ivl:Int(-5)))"},
}
Execname = {
	{"Process","Filez","Str","./file"},
	{"Process","Holez","Str","./hole"},
	{"Process","Linez","Str","./line"},
	{"Process","Planez","Str","./plane"},
	{"Process","Spacez","Str","./space"},
	{"Process","Pagez","Str","./page"},
	{"Process","Pipez","Str","./pipe"},
	{"Process","Framez","Str","./frame"},
	{"Process","Wavez","Str","./wave"},
	{"Process","Tapez","Str","./tape"},
	{"Process","Phonez","Str","./phone"},
}
--HERE Structs
Persist = {
	{"act","Goal",{},{}},
	{"idx","Int",{["act"]={
		["NewHub"]=true,["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubCfg"]=true,
		["ThdErr"]=true
	}},{}}, -- identifier for file
	{"loc","New",{["act"]={
		["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,["ThdThd"]=true,
		["HubCfg"]=true
	}},{}}, -- location in file
	{"pid","New",{["act"]={
		["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,["ThdThd"]=true
	}},{}}, -- process id for fifo
	{"slf","Int",{["act"]={
		["HubCfg"]=true
	}},{}}, -- whether process id is self
	{"str","Str",{["act"]={
		["NewHub"]=true,["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,
		["HubCfg"]=true,
		["ThdErr"]=true,["HubErr"]=true
	}},{}}, -- file or field
}
Term0 = {
	{"cff","Num",{},{}},
}
Term1 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{1}},
}
Term2 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{2}},
}
Term3 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{3}},
}
Nomial = {
	{"num0","Int",{},{}},
	{"trm0","Term0",{},"num0"},
	{"num1","Int",{},{}},
	{"trm1","Term1",{},"num1"},
	{"num2","Int",{},{}},
	{"trm2","Term2",{},"num2"},
	{"num3","Int",{},{}},
	{"trm3","Term3",{},"num3"},
}
Ratio = {
	{"num","Nomial",{},{}},
	{"den","Nomial",{},{}},
}
Event = { -- for line process
	{"tag","State",{},{}},
	{"idx","Int",{},{}},
	{"oth","Int",{},{}},
	{"key","Num",{},{}},
	{"val","Num",{},{}},
    {"upd","Ratio",{["tag"]={["Stock"]=true}},{}},
    {"dly","Ratio",{["tag"]={["Stock"]=true}},{}},
    {"sch","Ratio",{["tag"]={["Stock"]=true}},{}},
	{"flw","Flow",{["tag"]={["Bind"]=true}},{}},
	{"siz","Int",{["tag"]={["Wave"]=true}},{}},
	{"buf","Num",{["tag"]={["Wave"]=true}},"siz"},
	{"num","Int",{["tag"]={["Timer"]=true}},{}},
	{"tot","Int",{["tag"]={["Timer"]=true}},{}},
	{"ids","Int",{["tag"]={["Timer"]=true}},"num"},
	{"req","Int",{["tag"]={["Timer"]=true}},"num"},
	{"rsp","Num",{["tag"]={["Timer"]=true}},"tot"},
	{"wrp","Num",{["tag"]={["Audio"]=true}},{}},
	{"gap","Int",{["tag"]={["Audio"]=true}},{}},
	{"cdt","Int",{["tag"]={["Audio"]=true}},{}},
	{"len","Int",{["tag"]={["Audio"]=true}},{}},
	{"enb","Int",{["tag"]={["Audio"]=true}},{}},
}
Uniform = {
	{"all","Int",{},{}}, -- which subject to use
	{"one","Int",{},{}}, -- which element to use
	{"lon","Int",{},{}}, -- horizontal axis of cursor
	{"lat","Int",{},{}}, -- vertical axis of cursor
	{"len","Int",{},{}}, -- which subject for projection
	{"idx","Int",{},{}}, -- which plane to apply one matrix to
	{"use","Int",{},{}}, -- which basis to use
	{"siz","Int",{},{}}, -- size of swarm buffer
}
Triangle = {
	{"vtx","Int32",{},{4}}, -- points of triangle
	{"num","Int32",{},{}}, -- plane of points
	{"tex","Int32",{},{}}, -- texture of triangle
	{"pol","Int32",{},{}}, -- polytope triangle is in
	{"pad","Int32",{},{}},
}
Numeric = {
	{"vec","Old",{},{4}}, -- distances above basis
	{"bas","Int32",{},{}}, -- basis selector
	{"pad","Int32",{},{3}},
}
Vertex = {
	{"vec","Old",{},{4}}, -- intersection of planes
	{"ref","Int32",{},{3}}, -- backreference to planes
	{"pad","Int32",{},{}},
}
Pierce = {
	{"fix","Old",{},{4}},
	{"nml","Old",{},{4}},
	{"vld","Int32",{},{}},
	{"idx","Int32",{},{}},
	{"pad","Int32",{},{2}},
}
Vector = {
	{"vec","Old",{},{4}},
}
Matrix = {
	{"mat","Old",{},{16}},
}
Basis = {
	{"mat","Old",{},{36}},
}
Slice = {
	{"idx","Int",{},{}},
	{"siz","Int",{},{}},
}
BranchExp = {
	{"siz","Int",{},{}},
	{"lft","Express",{},"siz"},
	{"rgt","Express",{},"siz"},
	{"cmp","Compare",{},"siz"},
	{"str","Str",{},"siz"},
}
LeafExp = {
	{"siz","Int",{},{}},
	{"pat","Express",{},1},
	{"exp","Express",{},"siz"},
	{"str","Str",{},"siz"},
}
DataExp = { -- increment each nonnegative value from lookup of str in Data from eval of exp[0]
	{"act","Action",{},{}}, -- negate, clear, increment, result, or compare and possibly recurse
	{"siz","Int",{},{}}, -- zero unless act is SubAct
	-- negate, clear, or increment value of str as key, or add str to result Data
	{"str","Str",{["act"]={["NegAct"]=true,["ClrAct"]=true,["IncAct"]=true,["StrAct"]=true}},{}},
	{"key","Str",{["act"]={["SubAct"]=true}},"siz"}, -- str to lookup for value
	{"val","Int",{["act"]={["SubAct"]=true}},"siz"}, -- take actions if lookup value equals this
	{"sub","DataExp",{["act"]={["SubAct"]=true}},"siz"}, -- additional values to lookup
}
Hetgen = {
	{"siz","Int",{},{}},
	{"gen","Generic",{},"siz"},
}
Express = {
	{"opr","Operate",{},{}},
	{"opb","Express",{["opr"]={["AddOp"]=true,["SubOp"]=true,["MulOp"]=true,["DivOp"]=true,["RemOp"]=true}},2},
	{"pth","BranchExp",{["opr"]={["PthOp"]=true}},1},
	{"end","LeafExp",{["opr"]={["EndOp"]=true}},1},
	{"typ","Str",{["opr"]={["TotOp"]=true}},{}},
	{"tot","Express",{["opr"]={["TotOp"]=true}},1},
	{"cfg","Configure",{["opr"]={["GetOp"]=true}},{}},
	{"cgs","Configure",{["opr"]={["SetOp"]=true}},{}},
	{"set","Express",{["opr"]={["SetOp"]=true}},1},
	{"key","Str",{["opr"]={["ValOp"]=true}},{}},
	{"kys","Str",{["opr"]={["SavOp"]=true}},{}},
	{"sav","Express",{["opr"]={["SavOp"]=true}},1},
	{"ins","Express",{["opr"]={["InsOp"]=true}},4},
	{"ext","Express",{["opr"]={["ExtOp"]=true}},3},
	{"prm","Express",{["opr"]={["PrmOp"]=true}},2},
	{"cat","Express",{["opr"]={["CatOp"]=true}},2},
	{"siz","Int",{["opr"]={["HetOp"]=true,["HomOp"]=true}},{}},
	{"exp","Express",{["opr"]={["HetOp"]=true,["HomOp"]=true}},"siz"},
	{"val","Generic",{["opr"]={["ImmOp"]=true}},1},
	{"ivl","Int",{["opr"]={["IntOp"]=true}},{}},
	{"svl","Str",{["opr"]={["StrOp"]=true}},{}},
	{"cvl","Configure",{["opr"]={["CfgOp"]=true}},{}},
	{"mvl","Memory",{["opr"]={["MemOp"]=true}},{}},
	{"dtp","DataExp",{["opr"]={["DatOp"]=true}},1},
	{"dat","Express",{["opr"]={["DatOp"]=true}},1},
}
Machine = {
	{"xfr","Transfer",{},{}},
	{"siz","Int",{},{}},
	{"sav","Configure",{["xfr"]={["Stage"]=true}},"siz"},
	{"cfg","Configure",{["xfr"]={["Force"]=true}},"siz"},
	{"val","Int",{["xfr"]={["Force"]=true}},"siz"},
	{"exp","Express",{["xfr"]={["Jump"]=true,["Goto"]=true,["Eval"]=true}},1},
	{"lvl","Int",{["xfr"]={["Nest"]=true}},{}},
}
Center = {
	{"mem","Memory",{},{}},
	{"siz","Int",{},{}},
	{"idx","Int",{},{}},
	{"slf","Int",{},{}},
	{"tri","Triangle",{["mem"]={["Trianglez"]=true}},"siz"},
	{"num","Numeric",{["mem"]={["Numericz"]=true}},"siz"},
	{"vtx","Vertex",{["mem"]={["Vertexz"]=true}},"siz"},
	{"all","Matrix",{["mem"]={["Allmatz"]=true}},"siz"},
	{"few","Matrix",{["mem"]={["Fewmatz"]=true}},"siz"},
	{"one","Matrix",{["mem"]={["Onematz"]=true}},"siz"},
	{"swa","Vector",{["mem"]={["Swarmz"]=true}},"siz"},
	{"tex","Vector",{["mem"]={["Texturez"]=true}},"siz"},
	{"bas","Basis",{["mem"]={["Basisz"]=true}},"siz"},
	{"pie","Pierce",{["mem"]={["Piercez"]=true}},"siz"},
	{"rng","Slice",{["mem"]={["Slicez"]=true}},"siz"},
	{"str","Str",{["mem"]={["Stringz"]=true}},"siz"},
	{"mch","Machine",{["mem"]={["Machinez"]=true}},"siz"},
	{"cfg","Configure",{["mem"]={["Configurez"]=true}},"siz"},
	{"val","Int",{["mem"]={["Configurez"]=true}},"siz"},
}
Sculp = {
	{"cfg","Struc",{},{}},
}
Data = {
	{"siz","Int",{},{}},
	{"str","Str",{},"siz"},
	{"dat","Dat",{},{}},
}
Argument = {
	{"typ","Process",{},{}},
	{"inp","Int",{},{}},
	{"out","Int",{},{}},
	{"idx","Int",{},{}},
	{"str","Str",{["typ"]={["Holez"]=true}},{}},
}
Valve = {
	{"tag","Stream",{},{}},
	{"siz","Int",{["tag"]={["Fanout"]=true}},{}},
	{"dst","Str",{["tag"]={["Fanout"]=true}},"siz"},
	{"typ","Str",{["tag"]={["Fanout"]=true,["Buffer"]=true,["Execute"]=true}},{}},
	{"str","Str",{["tag"]={["Fanout"]=true,["Buffer"]=true}},{}},
	{"url","Str",{["tag"]={["Execute"]=true}},{}},
	{"arg","Argument",{["tag"]={["Execute"]=true}},1},
	{"exp","Express",{["tag"]={["Combine"]=true}},1},
	{"num","Int",{["tag"]={["Combine"]=true}},{}},
	{"dep","Str",{["tag"]={["Combine"]=true}},"num"},
}
--HERE
Enums,Enumz = listHere("Enums","type.gen")
Constants,Constantz = listHere("Constants","type.gen")
Structs,Structz = listHere("Structs","type.gen")
homgen = homgenStruct(Structz,Enumz,"Tag");
enum = genericEnum(Structz,Enumz,"Tag");
struct = genericStruct(Structz,Enumz,"Tag");
Enums[#Enums+1] = "Tag"; Enumz["Tag"] = enum
Structs[#Structs+1] = "Generic"; Structz["Generic"] = struct
Structs[#Structs+1] = "Homgen"; Structz["Homgen"] = homgen
function showTypeC()
	local result = ""
	result = result.."#include \"face.h\"\n"
	result = result.."#include \"type.h\"\n"
	result = result.."#include <stdlib.h>\n"
	result = result.."#include <string.h>\n"
	result = result.."#include <stdio.h>\n"
	result = result.."#include <unistd.h>\n"
	result = result.."#include <sys/errno.h>\n"
	result = result..showCallC().."\n"
	result = result.."int wrapExec(struct Argument *arg, const char *fork, const char *exec) {\n"
	result = result..showIndent(1).."int idx = openFork();\n"
	result = result..showIndent(1).."if (idx < 0) return -1;\n"
	result = result..showIndent(1).."if (openCheck(idx) >= 0) {\n"
	result = result..showIndent(2).."char *str = 0;\n"
	result = result..showIndent(2).."arg->inp=openRdfd(idx); arg->out=openWrfd(idx);\n"
	result = result..showIndent(2).."showArgument(arg,&str);\n"
	result = result..showIndent(2).."openExec(exec,str); fprintf(stderr,\"%s: cannot execute file: %s\\n\",fork,exec); ERROR();}\n"
	result = result..showIndent(1).."return idx;}\n"
	result = result.."int wrapType(enum Process typ, const char *fork, const char *exec) {\n"
	result = result..showIndent(1).."struct Argument arg = {0};\n"
	result = result..showIndent(1).."arg.typ = typ;\n"
	result = result..showIndent(1).."return wrapExec(&arg,fork,exec);}\n"
	result = result.."int wrapInit(struct Argument *arg, const char *str) {\n"
	result = result..showIndent(1).."int len = 0;\n"
	result = result..showIndent(1).."if (!hideArgument(arg,str,&len)) return -1;\n"
	result = result..showIndent(1).."arg->idx = rdwrInit(arg->inp,arg->out);\n"
	result = result..showIndent(1).."return 0;}\n"
	result = result.."int wrapIdent(enum Process typ, const char *str) {\n"
	result = result..showIndent(1).."struct Argument arg = {0};\n"
	result = result..showIndent(1).."if (wrapInit(&arg,str) < 0 || arg.typ != typ) return -1;\n"
	result = result..showIndent(1).."return arg.idx;}"
	return result
end
function showTypeH()
	local result = ""
	result = result.."#include \"proto.h\"\n"
	result = result..showCallH().."\n"
	result = result.."int wrapExec(struct Argument *arg, const char *fork, const char *exec);\n"
	result = result.."int wrapType(enum Process typ, const char *fork, const char *exec);\n"
	result = result.."int wrapInit(struct Argument *arg, const char *str);"
	result = result.."int wrapIdent(enum Process typ, const char *str);\n"
	return result
end
function showTypeHs()
	local result = ""
	result = result.."module Type where\n"
	result = result.."--\n"
	result = result.."import Face\n"
	result = result.."import System.Environment\n"
	result = result.."import System.IO\n"
	result = result.."import Data.IORef\n"
	result = result.."import Data.Int\n"
	result = result.."import Foreign.C.Types\n"
	result = result.."--\n"
	result = result.."type Dat = [CChar]\n"
	result = result..showCallHs().."\n"
	result = result.."wrapExec :: Argument -> String -> String -> IO (Maybe Int)\n"
	result = result.."wrapExec arg fork exec = do\n"
	result = result..showIndent(1).."idx <- openFork\n"
	result = result..showIndent(1).."if idx < 0 then return Nothing else do\n"
	result = result..showIndent(2).."vld <- openCheck idx\n"
	result = result..showIndent(2).."if vld < 0 then return (Just idx) else do\n"
	result = result..showIndent(3).."inp <- openRdfd idx\n"
	result = result..showIndent(3).."out <- openWrfd idx\n"
	result = result..showIndent(3).."ptr <- newIORef \"\"\n"
	result = result..showIndent(3).."showArgument (setArgumentCinp (setArgumentCout arg out) inp) ptr\n"
	result = result..showIndent(3).."str <- readIORef ptr\n"
	result = result..showIndent(3).."openExec exec str\n"
	result = result..showIndent(3).."hPutStrLn stderr (fork ++ \": cannot execute file: \" ++ exec)\n"
	result = result..showIndent(3).."callExit (negate 1)\n"
	result = result..showIndent(3).."return Nothing\n"
	result = result.."wrapType :: Process -> String -> String -> IO (Maybe Int)\n"
	result = result.."wrapType typ fork exec = wrapExec (Argument (ArgumentA1 typ 0 0 0) ArgumentA5Bs) fork exec\n"
	result = result.."wrapInitF :: Maybe Argument -> IO (Maybe Argument)\n"
	result = result.."wrapInitF Nothing = return Nothing\n"
	result = result.."wrapInitF (Just arg) = do\n"
	result = result..showIndent(1).."idx <- rdwrInit (getArgumentCinp arg) (getArgumentCout arg)\n"
	result = result..showIndent(1).."return (Just (setArgumentCidx arg idx))\n"
	result = result.."wrapInit :: String -> IO (Maybe Argument)\n"
	result = result.."wrapInit str = newRefStr str >>= hideArgument >>= wrapInitF\n"
	result = result.."wrapIdentF :: Process -> Maybe Argument -> IO (Maybe Int)\n"
	result = result.."wrapIdentF _ Nothing = return Nothing\n"
	result = result.."wrapIdentF typ (Just arg) = if typ /= (getArgumentCtyp arg) then\n"
	result = result..showIndent(1).."return Nothing else\n"
	result = result..showIndent(1).."return (Just (getArgumentCidx arg))\n"
	result = result.."wrapIdent :: Process -> String -> IO (Maybe Int)\n"
	result = result.."wrapIdent typ str = wrapInit str >>= wrapIdentF typ\n"
	return result
end
function showTypeLua()
	local result = ""
	result = result.."require \"face\"\n"
	result = result.."--\n"
	result = result..showCallLua().."\n"
	result = result.."function wrapExec(arg,fork,exec)\n"
	result = result..showIndent(1).."idx = openFork()\n"
	result = result..showIndent(1).."if (idx < 0) then return -1 end\n"
	result = result..showIndent(1).."if (openCheck(idx) >= 0) then\n"
	result = result..showIndent(1).."arg[\"inp\"]=openRdfd(idx); arg[\"out\"]=openWrfd(idx); arg[\"idx\"]=-1\n"
	result = result..showIndent(1).."if (arg[\"typ\"] == nil) then arg[\"typ\"] = \"Processs\"end\n"
	result = result..showIndent(2).."str = showArgument(arg,\"\")\n"
	result = result..showIndent(2).."openExec(exec,str); io.stderr:write(fork..\": cannot execute file: \"..exec..\"\\n\"); os.exit(-1)\n"
	result = result..showIndent(1).."end\n"
	result = result..showIndent(1).."return idx\n"
	result = result.."end\n"
	result = result.."function wrapType(typ,fork,exec)\n"
	result = result..showIndent(1).."arg[\"typ\"] = typ\n"
	result = result..showIndent(1).."return wrapExec(arg,fork,exec)\n"
	result = result.."end\n"
	result = result.."function wrapInit(str)\n"
	result = result..showIndent(1).."arg,len = hideArgument(str,0)\n"
	result = result..showIndent(1).."if (arg == nil) then return nil end\n"
	result = result..showIndent(1).."arg[\"idx\"] = rdwrInit(arg[\"inp\"],arg[\"out\"])\n"
	result = result..showIndent(1).."return arg\n"
	result = result.."end\n"
	result = result.."function wrapIdent(typ,str)\n"
	result = result..showIndent(1).."arg = wrapInit(str)\n"
	result = result..showIndent(1).."if (arg == nil) or not (arg[\"typ\"] == typ) then return -1 end\n"
	result = result..showIndent(1).."return arg[\"idx\"]\n"
	result = result.."end"
	return result
end
if (arg[1] == "type.dep") then
	file = io.open("type.dep", "w")
	file:close()
end
if (arg[1] == "type.h") then
	file = io.open("type.h", "w")
	file:write(showTypeH().."\n")
	file:close()
end
if (arg[1] == "type.c") then
	file = io.open("type.c", "w")
	file:write(showTypeC().."\n")
	file:close()
end
if (arg[1] == "type.hs") then
	file = io.open("type.hs", "w")
	file:write(showTypeHs().."\n")
	file:close()
end
if (arg[1] == "type.lua") then
	file = io.open("type.lua", "w")
	file:write(showTypeLua().."\n")
	file:close()
end
