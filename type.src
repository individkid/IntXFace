require "luax"

function showBool(bool)
	local str = ""
	if bool then str = "true" else str = "false" end
	return str
end
function showList(list)
	local str = ""
	for key,val in ipairs(list) do
		if str ~= "" then str = str.."," end
		str = str..val
	end
	return str
end
function listSort(map)
	local tab = {}
	for key,val in pairs(map) do
		table.insert(tab,key)
	end
	table.sort(tab)
	return tab
end
function showSet(set)
	if not set then return "universe" end
	local str = ""
	for key,val in ipairs(listSort(set)) do
		if str ~= "" then str = str.."," end
		if set[val] then str = str..val else str = str.."("..val..")" end
	end
	return str
end
function allOf(enum)
	local all = {}
	for key,val in pairs(enum) do all[val]=true end
	return all
end
function allExcept(enum,set)
	local all = {}
	for key,val in pairs(enum) do all[val] = not set[val] end
	return all
end
function allBefore(enum,lim)
	local all = {}
	local num = 0
	for key,val in pairs(enum) do if val == lim then num = key end end
	for key,val in pairs(enum) do all[val] = key < num end
	return all
end
function equalSetF(lhs,rhs)
	return (lhs and rhs) or (not lhs and not rhs)
end
function equalSet(lhs,rhs)
	local result = true
	for k,v in pairs(lhs) do result = result and equalSetF(rhs[k],v) end
	for k,v in pairs(rhs) do result = result and equalSetF(lhs[k],v) end
	return result
end
function interSet(lhs,rhs)
	local result = {}
	for k,v in pairs(lhs) do result[k] = v and rhs[k] end
	for k,v in pairs(rhs) do result[k] = v and lhs[k] end
	return result
end
function differSet(lhs,rhs)
	local result = {}
	for k,v in pairs(lhs) do result[k] = v and not rhs[k] end
	return result
end
function unionSet(lhs,rhs)
	local result = {}
	for k,v in pairs(lhs) do result[k] = v or rhs[k] end
	for k,v in pairs(rhs) do result[k] = v or lhs[k] end
	return result
end
-- for Set empty is {}
-- for Set universe is nil
-- for Plaid empty is nil
-- for Plaid universe is {}
-- all cannot be nil
-- all is the universe in a larger universe
-- all of {} is the largest universe
-- if all is {} then all sets are {}
function showPlaid(ds,all)
	if not ds then return "empty" end
	local empty = true; for k,v in pairs(ds) do empty = false end
	if empty then return "all" end
	local str = ""
	for k,v in ipairs(listSort(all)) do
		if str ~= "" then str = str..";" end
		if not ds[v] then str = str..v..":"..showSet(all[v])
		else str = str..v..":"..showSet(interSet(all[v],ds[v])) end
	end
	return str
end
function equalPlaid(lhs,rhs,all)
	if lhs == nil and rhs == nil then return true end
	if rhs == nil or lhs == nil then return false end
	local result = true
	for k,v in pairs(all) do
		local lhv = lhs[k]; -- if not lhv then lhv = all[k] end
		local rhv = rhs[k]; -- if not rhv then rhv = all[k] end
		if lhv and rhv then
			result = result and equalSet(lhv,rhv)
		else
			result = result and (not lhv) and (not rhv)
		end
	end
	return result
end
function interPlaid(lhs,rhs,all)
	if lhs == nil or rhs == nil then return nil end
	local result = {}
	for k,v in pairs(all) do
		local lhv = lhs[k]; if not lhv then lhv = all[k] end
		local rhv = rhs[k]; if not rhv then rhv = all[k] end
		result[k] = interSet(lhv,rhv)
		if equalSet(result[k],{}) then return nil end
	end
	return result
end
function showFind(found)
	local str = ""
	for k,v in ipairs(found) do
		if str ~= "" then str = str..";" end
		str = str..v[1]..","..v[2]
	end
	return str
end
function findString(str,pat)
	local result = {}
	for i = 1,str:len()-pat:len()+1 do
		local found = true
		for j = 1,pat:len() do
			if str:sub(i+j-1,i+j-1) ~= pat:sub(j,j) then found = false; break end
		end
		if found and i+pat:len() <= str:len() and str:sub(i+pat:len(),i+pat:len()) == "(" then
			table.insert(result,{i,pat:len()})
		end
		if found and i+pat:len() <= str:len() and str:sub(i+pat:len(),i+pat:len()) ~= "(" then
			table.insert(result,{i,-pat:len()})
		end
		if found and i+pat:len() > str:len() then
			table.insert(result,{i,-pat:len()})
		end
	end
	return result
end
function showAny(any)
	local result = ""
	if type(any) == "nil" then result = "nil"
	elseif type(any) == "boolean" and not any then result = "false"
	elseif type(any) == "boolean" and any then result = "true"
	elseif type(any) == "number" then result = tostring(any)
	elseif type(any) == "string" then result = "\""..any.."\""
	elseif type(any) == "table" then
		result = "{"
		for k,key in ipairs(listSort(any)) do
			if result ~= "{" then result = result.."," end
			result = result.."["..showAny(key).."]="..showAny(any[key])
		end
		result = result.."}"
	else result = type(any) end
	return result
end
function structTagSpace(struct)
	local all = {}
	local key = 1
	while struct[key] do
		local tags = struct[key][3]
		for k,v in pairs(tags) do
			if all[k] then all[k] = unionSet(all[k],v) else all[k] = v end
		end
		key = key + 1
	end
	return all
end
-- 1 2 3 4 5 6 7 8 9 a b
-- a a b b b c d e f g g  (b c d mutually disjoint)
--(   |     )       (   )
--    (         )
--(   |         | | |   )
function flatStruct(chain,split,cond)
	local last = #cond
	local link = 1
	local step = 1
	local single = 1
	local result = {}
	while (single <= last) do
		if (step <= #split) and (single >= split[step][1]) then
			if cond[split[step][1]] then result[#result+1] = split[step] end
			single = split[step][2] + 1
			while (link <= #chain) and (split[step][2] >= chain[link][2]) do
				link = link + 1
			end
			step = step + 1
		elseif (link <= #chain) and (single >= chain[link][1]) then
			if cond[chain[link][1]] then result[#result+1] = chain[link] end
			single = chain[link][2] + 1
			link = link + 1
		else
			if cond[single] then result[#result+1] = {single,single} end
			single = single + 1
		end
	end
	return result
end
function nestStruct(nest)
	-- return list of pairs of open on unequal and close on next unequal
	local result = {}
	local start = nil
	for k,v in ipairs(nest) do
		if v and not start then start = k end
		if not v and start then result[#result+1] = {start,k}; start = nil end
	end
	if start then result[#result+1] = {start,#nest} end
	return result
end
function condStruct(struct)
	local result = {}
	for k,v in ipairs(struct) do
		local empty = true; for k,v in pairs(v[3]) do empty = false end
		result[#result+1] = not empty
	end
	return result
end
--  1 2 3 4 5 6 7 8 9 a b
--  a a b b b c d e f g g
--  1 0 1 1 0 0 0 0 0 1 0  (0 unequal, 1 equal)
-- + 0 * 0 0 - 0 0 0 + 0 - (+ open, * close/open, - close struct)
--  (1,2),(3,5),(a,b)      (open struct, close before opens)
function chainStruct(struct)
	-- return list of bool of whether successive fields are equal with first and last false
	local all = structTagSpace(struct)
	local result = {}
	for k,v in ipairs(struct) do
		result[#result+1] = (struct[k+1] ~= nil) and equalPlaid(v[3],struct[k+1][3],all)
	end
	return result
end
--  1 2 3 4 5 6 7 8 9 a b
--  a a b b b c d e f g g  (b c d mutually disjoint)
--  0 0 1 1 1 1 0 0 0 0 0  (0 conjoint, 1 disjoint back to conjoint)
-- 0 0 + 0 0 0 0 - 0 0 0 0 (+ open, - close union)
-- (3,7) (open union before open struct, close before opens)
function splitStructF(field,sofar,all)
	for k,v in ipairs(sofar) do
		if not equalPlaid(interPlaid(v,field,all),nil,all) then
			return false
		end
	end
	return true
end
function splitStruct(struct)
	-- return list of bool of whether successive structs are disjoint with first and last false
	local all = structTagSpace(struct)
	local result = {}
	local sofar = {}
	local skip = 0
	local joint = 0
	for k,v in ipairs(struct) do
		if (#sofar == 0) then
			skip = skip + 1
			sofar = {v[3]}
		elseif equalPlaid(v[3],sofar[#sofar],all) then
			skip = skip + 1
			sofar[#sofar+1] = v[3]
		elseif splitStructF(v[3],sofar,all) then
			skip = skip + 1
			joint = joint + 1
			sofar[#sofar+1] = v[3]
		elseif (joint > 0) then
			while (skip > 0) do result[#result+1] = true; skip = skip - 1 end
			result[#result] = false
			skip = skip + 1
			sofar = {v[3]}
			joint = 0
		else
			while (skip > 0) do result[#result+1] = false; skip = skip - 1 end
			skip = skip + 1
			sofar = {v[3]}
		end
 	end
 	if (joint > 0) then
		while (skip > 0) do result[#result+1] = true; skip = skip - 1 end
 	else
		while (skip > 0) do result[#result+1] = false; skip = skip - 1 end
 	end
	return result
end
function stringStructF(ary,idx,sub,any,dif,cum,sum)
	if ary[sub] and (idx == ary[sub][1]) then
		any = any + 1
		dif = dif + 1
		sum = sum + 1
		cum = cum + 1
	end
	if ary[sub] and (idx == ary[sub][2]) then
		any = any + 1
		dif = dif - 1
		sum = sum - 1
		cum = cum - 1
	end
	if ary[sub] and (idx == ary[sub][2]) then
		sum = sum + 1
	end
	if (any > 1) then
		any = any - 1
	end
	if ary[sub] and (idx == ary[sub][2]) then
		sub = sub + 1
	end
	return sub,any,dif,cum,sum
end
function stringStruct(struct,chain,split,func)
	local result = ""
	local link = 1
	local step = 1
	local chainz = 0
	local splitz = 0
	for k,v in ipairs(struct) do
		local linkz = 0
		local links = 0
		local chains = chainz
		link,linkz,links,chainz,chains = stringStructF(chain,k,link,linkz,links,chainz,chains)
		local stepz = 0 -- transition
		local steps = 0 -- increase or decrease
		local splits = splitz -- current = cumulative
		step,stepz,steps,splitz,splits = stringStructF(split,k,step,stepz,steps,splitz,splits)
		-- index transition direction level
		result = result..func(k,linkz,stepz,links,steps,chains,splits)
	end
	return result
end
function treeStruct(limit,chain,split,index,link,step)
	if (index >= limit) then return {} end
	local begi = limit; if chain[link] then begi = chain[link][1] end
	local endi = limit; if chain[link] then endi = chain[link][2] end
	local mini = limit; if split[step] then mini = split[step][1] end
	local maxi = limit; if split[step] then maxi = split[step][2] end
	if (index < begi) and (index < mini) then
		local head = {index,index,"field",{}}
		local tail = treeStruct(limit,chain,split,index+1,link,step)
		table.insert(tail,1,head)
		return tail
	end
	if (index == mini) then
		local head = {mini,maxi,"union",treeStruct(maxi+1,chain,split,mini,link,step+1)}
		while chain[link] and (chain[link][1] < split[step][2]) do link = link + 1 end
		local tail = treeStruct(limit,chain,split,maxi+1,link,step+1)
		table.insert(tail,1,head)
		return tail
	end
	if (index == begi) then
		local head = {begi,endi,"struct",treeStruct(endi+1,chain,split,begi,link+1,step)}
		local tail = treeStruct(limit,chain,split,endi+1,link+1,step)
		table.insert(tail,1,head)
		return tail
	end
	return {}
end
function showIndent(depth)
	local indent = ""; c = 0 while c < depth do c = c + 1; indent = indent.."    " end
	return indent
end
function showEnumC(name,enum)
	local str = "enum "..name.." {\n"
	for key,val in ipairs(enum) do
		str = str..showIndent(1)..val..",\n"
	end
	str = str..showIndent(1)..name.."s\n"
	str = str.."};"
	return str
end
function showStructCH(val)
	local decl
	if (Enumz[val[2]]~=nil) then
		decl = "enum "..val[2]
	elseif (Structz[val[2]]~=nil) then
		decl = "struct "..val[2]
	elseif (val[2] == "Chr") then
		decl = "char"
	elseif (val[2] == "Int") then
		decl = "int"
	elseif (val[2] == "New") then
		decl = "long long"
	elseif (val[2] == "Num") then
		decl = "double"
	elseif (val[2] == "Old") then
		decl = "float"
	elseif (val[2] == "Str") then
		decl = "char*"
	else
		decl = val[2]
	end
	if (type(val[4]) == "number") then
		decl = decl.."*"
	elseif (type(val[4]) == "string") then
		decl = decl.."*"
	end
	return decl
end
function showStructCG(val)
	local ident = val[1]
	if (type(val[4]) == "table") then
		for k,v in pairs(val[4]) do
			ident = ident.."["..v.."]"
		end
	end
	return ident
end
function showStructCF(val)
	local decl = showStructCH(val)
	local ident = showStructCG(val)
	return decl.." "..ident..";"
end
function showStructC(name,struct)
	local all = structTagSpace(struct)
	local chain = nestStruct(chainStruct(struct))
	local split = nestStruct(splitStruct(struct))
	local result = ""
	local link = 1
	local step = 1
	local depth = 1
	local single = 1
	for k,v in ipairs(struct) do
		if split[step] and k == split[step][1] then
			result = result..showIndent(depth).."union {\n"
			depth = depth + 1
		end
		if chain[link] and k == chain[link][1] then
			result = result..showIndent(depth).."struct { // "
			result = result..showPlaid(v[3],all).."\n"
			single = 0; depth = depth + 1
		end
		if single == 1 then
			result = result..showIndent(depth)..showStructCF(v).." // "
			result = result..showPlaid(v[3],all).."\n"
		else
			result = result..showIndent(depth)..showStructCF(v).."\n"
		end
		if chain[link] and k == chain[link][2] then
			single = 1; depth = depth - 1; link = link + 1
			result = result..showIndent(depth).."};\n"
		end
		if split[step] and k == split[step][2] then
			depth = depth - 1; step = step + 1
			result = result..showIndent(depth).."};\n"
		end
	end
	return "struct "..name.." {\n"..result.."};"
end
function showCondC(struct,dset)
	local cond = ""
	local terms = 0
	for i,dim in ipairs(listSort(dset)) do
		local set = dset[dim]
		local term = ""
		local factors = 0
		for idx,fld in ipairs(struct) do
			if (fld[1] == dim) then
				for j,val in ipairs(listSort(set)) do
					local factor = "ptr->"..struct[idx][1].." == "..val
					if (factors > 0) then term = term.." || " end
					term = term.."("..factor..")"
					factors = factors + 1
				end
			end
		end
		if (terms > 0) then cond = cond.." && " end
		if (factors > 1) then
			cond = cond.."("..term..")"
		else
			cond = cond..term
		end
		terms = terms + 1
	end
	if (terms == 0) then
		cond = "1"
	elseif (terms > 1) then
		cond = "("..cond..")"
	end
	return cond
end
function showStreamCF(name,field,lim)
	local result = ""
	result = result.."alloc"..name.."(&ptr->"..field..","..lim..");"
	return result
end
function showStreamC(name,struct,show,pre,post)
	local result = ""
	result = result..pre..name.."(struct "..name.." *ptr"..post..")"
	if prototype then return result..";" end
	result = result.."\n{\n"
	if (show == showSizeCF) then
		result = result..showIndent(1).."int result = 0;\n"
	end
	if (show == showRandCF or show == showReadCF) then
		result = result..showIndent(1).."free"..name.."(ptr);\n"
	end
	if (show == showShowCF) then
		result = result..showIndent(1).."showOpen(\""..name.."\",str,len);\n"
	end
	if (show == showHideCF) then
		result = result..showIndent(1).."allocMark();\n"
		result = result..showIndent(1).."if (!hideOpen(\""..name.."\",str,len)) {allocDrop(); return 0;}\n"
	end
	local all = structTagSpace(struct)
	for k,v in ipairs(struct) do
		local depth = 1
		local plaid = v[3]
		local fields = listSort(plaid)
		local cond = showCondC(struct,plaid)
		local sub = nil
		local arg = nil
		local lim = nil
		local ebr = ""
		if (show==showFreeCF) and (Structz[v[2]]==nil) and (v[2] ~= "Str") and
			(type(v[4]) ~= "number") and (type(v[4]) ~= "string") then
			cond = "1"
		end
		if (cond ~= "1") then
			result = result..showIndent(depth)
			result = result.."if "..cond.." {".."\n"
			ebr = ebr.."}"
			depth = depth + 1
		end
		if (type(v[4]) == "table") and
			(show ~= showFreeCF or Structz[v[2]]~=nil) then
			sub = ""
			arg = {}
			for key,val in ipairs(v[4]) do
				result = result..showIndent(depth)
				result = result.."for (int i"..key.." = 0; i"..key.." < "..val.."; i"..key.."++)\n"
				sub = sub.."[i"..key.."]"
				arg[#arg+1] = "i"..key
				depth = depth + 1
			end
		elseif (type(v[4]) == "number") and
			(show ~= showFreeCF or Structz[v[2]]~=nil) then
			sub = ""
			arg = {}
			lim = v[4]
		elseif (type(v[4]) == "string") and
			(show ~= showFreeCF or Structz[v[2]]~=nil) then
			sub = ""
			arg = {}
			lim = "ptr->"..v[4]
		elseif (type(v[4]) == "number") or (type(v[4]) == "string") or
			(v[2] == "Str" and show == showFreeCF) then
			sub = ""
		end
		if lim then
			if (show == showReadCF) or (show == showRandCF) or (show == showHideCF) then
				result = result..showIndent(depth).."alloc"..v[2].."(&ptr->"..v[1]..","..lim..");\n"
			end
			result = result..showIndent(depth)
			result = result.."for (int i = 0; i < "..lim.."; i++)\n"
			sub = "[i]"
			arg = {"i"}
			depth = depth + 1
			result = result..showIndent(depth)
		elseif (sub ~= nil) or (show ~= showFreeCF) then
			result = result..showIndent(depth)
		end
		if (sub ~= nil) then
			result = result..show(v,ebr,sub,arg)
		elseif (show ~= showFreeCF) then
			result = result..ebr.."// "..showAny(v).."\n"
		end
	end
	if (show == showCompCF) then
		result = result..showIndent(1).."return 1;\n"
	end
	if (show == showSizeCF) then
		result = result..showIndent(1).."return result;\n"
	end
	if (show == showShowCF) then
		result = result..showIndent(1).."showClose(str,len);\n"
	end
	if (show == showHideCF) then
		result = result..showIndent(1).."if (!hideClose(str,len)) {allocDrop(); return 0;}\n"
		result = result..showIndent(1).."allocKeep();\n"
		result = result..showIndent(1).."return 1;\n"
	end
	result = result.."}"
	return result
end
function showOffsetC(name,struct)
	local result = ""
	for k,v in ipairs(struct) do
		local camel = string.upper(string.sub(v[1],1,1))..string.sub(v[1],2)
		if result ~= "" then result = result.."\n" end
		result = result.."int offset"..name..camel.."()"
		if prototype then
			result = result..";"
		else
			result = result.."\n"
			result = result.."{\n"
			result = result..showIndent(1).."return (int)(long long)&(((struct "..name.." *)0)->"..v[1]..");\n"
			result = result.."}"
		end
	end
	return result
end
function showFreeCF(v,ebr,sub)
	local result = ""
	if (Structz[v[2]]~=nil) then
		local depth = 1; while (string.sub(ebr,depth,1) == "}") do depth = depth + 1 end
		result = result.."free"..v[2].."("
		if (sub ~= "") or (type(v[4]) == "table") then result = result.."&" end
		result = result.."ptr->"..v[1]..sub..");"
		if (type(v[4]) == "number") or (type(v[4]) == "string") then
			result = result.."\n"
			result = result..showIndent(depth).."alloc"..v[2].."(&ptr->"..v[1]..",0);\n"
		end
		result = result..ebr.."\n"
	elseif (type(v[4]) == "number") or (type(v[4]) == "string") then
		result = result.."alloc"..v[2].."(&ptr->"..v[1]..",0);"..ebr.."\n"
	elseif (v[2] == "Str") then
		result = result.."assignStr(&ptr->"..v[1]..",0);"..ebr.."\n"
	else
		result = result..ebr.." // "..showAny(v).."\n"
	end
	return result
end
function showFreeC(name,struct)
	return showStreamC(name,struct,showFreeCF,"void free","")
end
function showAllocC(name,typ)
	local result = ""
	if (Enumz[name] ~= nil) then
		result = result.."void alloc"..name.."(enum "..name.." **ptr, int siz)"
		if prototype then return result..";" else result = result.."\n{\n" end
		result = result..showIndent(1).."if (*ptr && siz == 0) {free(*ptr); *ptr = 0;}\n"
		result = result..showIndent(1).."if (siz == 0) return;\n"
		result = result..showIndent(1).."allocMem((void**)ptr,siz*sizeof(enum "..name.."));\n"
		result = result..showIndent(1).."if (*ptr == 0) ERROR(exitErr,-1)\n"
		result = result..showIndent(1).."for (int i = 0; i < siz; i++) (*ptr)[i] = 0;\n"
		result = result.."}"
	elseif (Structz[name] ~= nil) then
		result = result.."void alloc"..name.."(struct "..name.." **ptr, int siz)"
		if prototype then return result..";" else result = result.."\n{\n" end
		result = result..showIndent(1).."if (*ptr && siz == 0) {free(*ptr); *ptr = 0;}\n"
		result = result..showIndent(1).."if (siz == 0) return;\n"
		result = result..showIndent(1).."allocMem((void**)ptr,siz*sizeof(struct "..name.."));\n"
		result = result..showIndent(1).."if (*ptr == 0) ERROR(exitErr,-1)\n"
		result = result..showIndent(1).."struct "..name.." init = {0};\n"
		result = result..showIndent(1).."for (int i = 0; i < siz; i++)\n"
		result = result..showIndent(2).."memcpy(&(*ptr)[i],&init,sizeof(init));\n"
		result = result.."}"
	end
	return result
end
function showReadCF(v,ebr,sub)
	local result = ""
	if (Enumz[v[2]]~=nil) then
		result = result.."{int temp = readInt(idx); ptr->"..v[1]..sub.." = temp;}"..ebr.."\n"
	elseif (Structz[v[2]]~=nil) then
		result = result.."read"..v[2].."(&ptr->"..v[1]..sub..",idx);"..ebr.."\n"
	elseif (v[2] == "Str") then
		result = result.."readStr(callStr,&ptr->"..v[1]..sub..",idx);"..ebr.."\n"
	else
		result = result.."ptr->"..v[1]..sub.." = read"..v[2].."(idx);"..ebr.."\n"
	end
	return result
end
function showWriteCF(v,ebr,sub)
	local result = ""
	if (Enumz[v[2]]~=nil) then
		result = result.."{int temp = ptr->"..v[1]..sub.."; writeInt(temp,idx);}"..ebr.."\n"
	elseif (Structz[v[2]]~=nil) then
		result = result.."write"..v[2].."(&ptr->"..v[1]..sub..",idx);"..ebr.."\n"
	elseif (v[2] == "Str") then
		result = result.."writeStr(ptr->"..v[1]..sub..",1,idx);"..ebr.."\n"
	else
		result = result.."write"..v[2].."(ptr->"..v[1]..sub..",idx);"..ebr.."\n"
	end
	return result
end
function showReadC(name,struct)
	return showStreamC(name,struct,showReadCF,"void read",", int idx")
end
function showWriteC(name,struct)
	return showStreamC(name,struct,showWriteCF,"void write",", int idx")
end
randChr = 1
randInt = 10
randNew = 100
randNum = 0.1
randOld = 0.2
function showRandCF(v,ebr,sub)
	local result = ""
	if (Enumz[v[2]]~=nil) then
		result = result.."ptr->"..v[1]..sub.." = "..randInt.."%"..v[2].."s;"..ebr.."\n"
		randInt = randInt + 1;
	elseif (Structz[v[2]]~=nil) then
		result = result.."rand"..v[2].."(&ptr->"..v[1]..sub..");"..ebr.."\n"
	elseif (v[2] == "Chr") then
		result = result.."ptr->"..v[1]..sub.." = "..randChr..";"..ebr.."\n"
		randChr = randChr + 1;
	elseif (v[2] == "Int") then
		result = result.."ptr->"..v[1]..sub.." = "..randInt..";"..ebr.."\n"
		randInt = randInt + 1;
	elseif (v[2] == "New") then
		result = result.."ptr->"..v[1]..sub.." = "..randNew..";"..ebr.."\n"
		randNew = randNew + 1;
	elseif (v[2] == "Num") then
		result = result.."ptr->"..v[1]..sub.." = "..randNum..";"..ebr.."\n"
		randNum = randNum + 1.0
	elseif (v[2] == "Old") then
		result = result.."ptr->"..v[1]..sub.." = "..randOld..";"..ebr.."\n"
		randNum = randNum + 1.0
	elseif (v[2] == "Str") then
		result = result.."{const char *temp = \"hello ok again\"; "
		result = result.."assignStr(&ptr->"..v[1]..sub..",temp);}"..ebr.."\n"
	else
		result = result..ebr.." // "..showAny(v).."\n"
	end
	return result
end
function showCompCF(v,ebr,sub)
	local result = ""
	if (Structz[v[2]]~=nil) then
		result = result.."if (!comp"..v[2].."(&ptr->"..v[1]..sub..", &cmp->"..v[1]..sub..")) return 0;"..ebr.."\n"
	elseif (v[2] == "Chr") or (v[2] == "Int") or (v[2] == "New") or (v[2] == "Num") or (v[2] == "Old") or (Enumz[v[2]]~=nil) then
		result = result.."if (ptr->"..v[1]..sub.." != cmp->"..v[1]..sub..") return 0;"..ebr.."\n"
	elseif (v[2] == "Str") then
		result = result.."if (strcmp(ptr->"..v[1]..sub..",cmp->"..v[1]..sub..") != 0) return 0;"..ebr.."\n"
	else
		result = result..ebr.."; // "..showAny(v).."\n"
	end
	return result
end
function showSizeCF(v,ebr,sub)
	local result = ""
	if (Enumz[v[2]]~=nil) then
		result = result.."result = result + sizeof(int);"..ebr.."\n"
	elseif (v[2] == "Str") then
		result = result.."result = result + strlen(ptr->"..v[1]..sub..") + 1;"..ebr.."\n"
	elseif (Structz[v[2]]~=nil) then
		result = result.."result = result + size"..v[2].."(&ptr->"..v[1]..sub..");"..ebr.."\n"
	elseif (v[2] == "Chr") then
		result = result.."result = result + sizeof(char);"..ebr.."\n"
	elseif (v[2] == "Int") then
		result = result.."result = result + sizeof(int);"..ebr.."\n"
	elseif (v[2] == "New") then
		result = result.."result = result + sizeof(long long);"..ebr.."\n"
	elseif (v[2] == "Num") then
		result = result.."result = result + sizeof(double);"..ebr.."\n"
	elseif (v[2] == "Old") then
		result = result.."result = result + sizeof(float);"..ebr.."\n"
	else
		result = result..ebr.."; // "..showAny(v).."\n"
	end
	return result
end
function showRandC(name,struct)
	return showStreamC(name,struct,showRandCF,"void rand","")
end
function showCompC(name,struct)
	return showStreamC(name,struct,showCompCF,"int comp",", struct "..name.." *cmp")
end
function showSizeC(name,struct)
	return showStreamC(name,struct,showSizeCF,"int size","")
end
function showShowCG(name)
	local result = ""
	if (name == "Chr") then
		result = result.."c"
	elseif (name == "Int") then
		result = result.."d"
	elseif (name == "New") then
		result = result.."lld"
	elseif (name == "Num") then
		result = result.."lf"
	elseif (name == "Old") then
		result = result.."f"
	elseif (name == "Str") then
		result = result.."s"
	end
	return result
end
function showShowCH(pre,i)
	local result = ""
	if (i == 1) then
		result = result..pre.."["
	else
		result = result.."["
	end
	return result
end
function showShowCI(i,max)
	local result = ""
	if (i == max) then
		result = result.."]:"
	else
		result = result.."]"
	end
	return result
end
function showShowCF(v,ebr,sub,arg)
	local result = ""
	result = result.."{"
	if (#arg == 0) then
		result = result.."showField(\""..v[1].."\",str,len); "
	end
	for i,_ in ipairs(arg) do
		result = result.."showStruct(\""..showShowCH(v[1],i).."\","..arg[i]..",\""..showShowCI(i,#arg).."\",str,len); "
	end
	result = result.."show"..v[2].."("
	if (Structz[v[2]]~=nil) then
		result = result.."&"
	end
	result = result.."ptr->"..v[1]..sub..",str,len);}"..ebr.."\n"
	return result
end
function showHideCF(v,ebr,sub,arg)
	local result = ""
	result = result.."if ("
	if (#arg == 0) then
		result = result.."!hideField(\""..v[1].."\",str,len) || "
	end
	for i,_ in ipairs(arg) do
		result = result.."!hideStruct(\""..showShowCH(v[1],i).."\","..arg[i]..",\""..showShowCI(i,#arg).."\",str,len) || "
	end
	result = result.."!hide"..v[2].."(&ptr->"..v[1]..sub..",str,len)) {allocDrop(); return 0;}"..ebr.."\n"
	return result
end
function showShowC(name,typ)
	local result = ""
	if (Enumz[name] ~= nil) then
		result = result.."void show"..name.."(enum "..name.." val, char **str, int *len)"
		if prototype then result = result..";\n" else result = result.."\n{\n"
		result = result..showIndent(1).."switch (val) {\n"
		for i,v in ipairs(typ) do
			result = result..showIndent(2).."case("..v.."): showEnum(\""..name.."\",\""..v.."\",str,len); break;\n"
		end
		result = result..showIndent(2).."case("..name.."s): showEnum(\""..name.."\",\""..name.."s\",str,len); break;\n"
		result = result..showIndent(1).."}\n"
		result = result.."}" end
	elseif (Structz[name] ~= nil) then
		result = result..showStreamC(name,typ,showShowCF,"void show",", char **str, int *len")
		return result
	end
	return result
end
function showHideC(name,typ)
	local result = ""
	if (Enumz[name] ~= nil) then
		result = result.."int hide"..name.."(enum "..name.." *val, const char *str, int *len)"
		if prototype then result = result..";\n" else result = result.."\n{\n"
		for i,v in ipairs(typ) do
			result = result..showIndent(1).."if (hideEnum(\" "..name.."\",\""..v.."\",str,len)) {*val = "..v.."; return 1;}\n"
		end
		result = result..showIndent(1).."if (hideEnum(\" "..name.."\",\""..name.."s\",str,len)) {*val = "..name.."s; return 1;}\n"
		result = result..showIndent(1).."allocDrop();\n"
		result = result..showIndent(1).."return 0;\n"
		result = result.."}" end
	elseif (Structz[name] ~= nil) then
		return showStreamC(name,typ,showHideCF,"int hide",", const char *str, int *len")
	end
	return result
end
function showConstantCF(name,sub,list)
	local result = name
	local last = nil
	if k == #list then
		return list[#list]
	end
	for k,v in ipairs(list) do
		if last then
			if k < sub and sub < #list then
				result = result.."_"..string.gsub(v,"[ ():]","_")
			elseif k == sub and sub == #list and last == "Str" then
				result = "\""..v.."\""
			elseif k == sub and sub == #list and last == "Int" then
				result = "(int)"..v
			elseif k == sub and sub == #list then
				result = v
			elseif k == sub then
				result = result.."__"..last
			elseif k == (sub+2) then
				result = result.."__"..last
			else
				result = result.."_"..last
			end
			last = nil
		else
			last = v
		end
	end
	return result
end
function showConstantCG(sub,list)
	local result = {}
	local last = nil
	for k,v in ipairs(list) do
		if last then
			if k >= sub and last == "Str" then
				result[#result+1] = "char *"
			elseif k >= sub and last == "Int" then
				result[#result+1] = "int"
			elseif k >= sub then
				result[#result+1] = "enum "..last
			end
			last = nil
		else
			last = v
		end
	end
	return result
end
function showConstantC(name,constant)
	local result = ""
	local mapping = {}
	local arguments = {}
	local values = {}
	for key,val in ipairs(constant) do
		local goon = true
		nestInit(#val)
		for k,v in ipairs(val) do nestElem(k-1,v) end
		nestScan()
		while goon do
			local line = {}
			goon = not (nestPass() == 0)
			for k,v in ipairs(val) do line[#line+1] = nestRepl(k-1) end
			values[#values+1] = line
		end
	end
	nestInit(0)
	for key,val in ipairs(values) do
		local last = nil
		for k,v in ipairs(val) do
			if last and (k < #val) then -- last is type, v is constant
				local func = showConstantCF(name,k,val) -- func is containing function
				local gunc = showConstantCF(name,k+2,val) -- gunc is return value
				local args = showConstantCG(k,val) -- args are argument types
				-- io.stderr:write("func "..func.." v "..v.." gunc "..gunc.." k "..k.."/"..#val.."\n")
				if not arguments[func] then arguments[func] = args end
				if not mapping[func] then mapping[func] = {} end
				mapping[func][v] = gunc
				last = nil
			else -- v is type
				last = v
			end
		end
	end
	for key,val in pairs(arguments) do if #val > 1 then
		local declare = key.." ("
		-- result = result.."func "..key.."(_ arg: "
		for k,v in ipairs(val) do
			-- io.stderr:write("k "..k.."/"..#val.." v "..v.."\n")
			if k == #val then
				declare = v.." "..declare
				-- io.stderr:write("declare "..declare.."\n")
				if prototype then
					result = result..declare..";\n"
				else
					result = result..declare.."\n"
					result = result.."{\n"
					result = result.."    switch (arg) {\n"
				end
			elseif k == 1 then
				declare = declare..v.." arg)"
			else
				declare = "(*"..declare..")("..v..")"
			end
		end
		if not prototype then
			for k,v in pairs(mapping[key]) do
				result = result.."        case ("..k.."): return "..v..";\n"
			end
			result = result.."        default : return 0;\n"
			result = result.."    }\n"
			result = result.."}\n"
		end
	end end
	result = result.."//"
	return result
end
function showRstructC(list)
	local result = ""
	result = result.."void readStruct(sftype fnc, void *arg, int typ, int idx)"
	if prototype then return result..";\n" end
	result = result.."\n{\n"
	result = result..showIndent(1).."int len = 0;\n"
	result = result..showIndent(1).."char *str = 0;\n"
	result = result..showIndent(1).."switch (typ) {\n"
	for k,v in ipairs(list) do
		result = result..showIndent(1).."case("..(k-1).."): {\n"
		result = result..showIndent(2).."struct "..v.." tmp = {0};\n"
		result = result..showIndent(2).."read"..v.."(&tmp,idx);\n"
		result = result..showIndent(2).."show"..v.."(&tmp,&str,&len);\n"
		result = result..showIndent(2).."break;}\n"
	end
	result = result..showIndent(1).."}\n"
	result = result..showIndent(1).."fnc(str,1,idx,arg);\n"
	result = result..showIndent(1).."free(str);\n"
	result = result.."}\n"
	return result
end
function showWstructC(list)
	local result = ""
	result = result.."void writeStruct(const char *str, int typ, int idx)"
	if prototype then return result..";\n" end
	result = result.."\n{\n"
	result = result..showIndent(1).."int len = 0;\n"
	result = result..showIndent(1).."switch (typ) {\n"
	for k,v in ipairs(list) do
		result = result..showIndent(1).."case("..(k-1).."): {\n"
		result = result..showIndent(2).."struct "..v.." tmp = {0};\n"
		result = result..showIndent(2).."hide"..v.."(&tmp,str,&len);\n"
		result = result..showIndent(2).."write"..v.."(&tmp,idx);\n"
		result = result..showIndent(2).."break;}\n"
	end
	result = result..showIndent(1).."}\n"
	result = result.."}\n"
	return result
end
function showIstructC(list)
	local result = ""
	result = result.."int identStruct(const char *str)"
	if prototype then return result..";\n" end
	result = result.."\n{\n"
	result = result..showIndent(1).."int len = 0;\n"
	for k,v in ipairs(list) do
		result = result..showIndent(1).."if (hideIdent(\""..v.."\",str,&len)) return "..(k-1)..";\n"
	end
	result = result..showIndent(1).."return -1;\n"
	result = result.."}\n"
	return result
end
function showEnumHs(name,enum)
	local result = "data "..name.." =\n"
	for key,val in ipairs(enum) do
		result = result..showIndent(1)..val.." |\n"
	end
	result = result..showIndent(1)..name.."s deriving (Eq)\n"
	return result.."--"
end
function showCodeHs(name,enum)
	local result = ""
	result = result.."read"..name.."F :: Int -> IO "..name.."\n"
	for key,val in ipairs(enum) do
		result = result.."read"..name.."F "..(key-1).." = return "..val.."\n"
	end
	result = result.."read"..name.."F _ = return "..name.."s\n"
	result = result.."read"..name.." :: Int -> IO "..name.."\n"
	result = result.."read"..name.." idx = (readInt idx) >>= read"..name.."F\n"
	result = result.."write"..name.."F :: "..name.." -> Int\n"
	for key,val in ipairs(enum) do
		result = result.."write"..name.."F "..val.." = "..(key-1).."\n"
	end
	result = result.."write"..name.."F _ = "..#enum.."\n"
	result = result.."write"..name.." :: "..name.." -> Int -> IO ()\n"
	result = result.."write"..name.." a idx = writeInt (write"..name.."F a) idx\n"
	result = result.."--"
	return result
end
function showStructHsF(val)
	local result = ""
	local pre = ""
	local post = ""
	if ((type(val[4]) == "table") and (#val[4] > 0)) then
		local count = 1
		while (count <= #val[4]) do
			pre = pre.."["
			post = post.."]"
			count = count + 1
		end
	end
	if (type(val[4]) == "number") or (type(val[4]) == "string") then
		pre = "["
		post = "]"
	end
	result = result..showStructHsG(val[2],pre,post)
	return result
end
function showStructHsG(name,pre,post)
	local result = ""
	if (name == "Chr") and language then
		result = result..pre.."Character"..post
	elseif (name == "Chr") then
		result = result..pre.."Char"..post
	elseif (name == "Int") and language then
		result = result..pre.."Int32"..post
	elseif (name == "Int") then
		result = result..pre.."Int"..post
	elseif (name == "New") and language then
		result = result..pre.."Int64"..post
	elseif (name == "New") then
		result = result..pre.."Integer"..post
	elseif (name == "Num") then
		result = result..pre.."Double"..post
	elseif (name == "Old") then
		result = result..pre.."Float"..post
	elseif (name == "Str") then
		result = result..pre.."String"..post
	else
		result = result..pre..name..post
	end
	return result
end
function showStructHs(name,struct)
	local all = structTagSpace(struct)
	local chain = nestStruct(chainStruct(struct))
	local split = flatStruct(chain,nestStruct(splitStruct(struct)),condStruct(struct))
	local result = ""
	local structs = 1
	result = result..stringStruct(struct,chain,split,
		function(index,linkz,stepz,links,steps,chains,splits)
		-- index transition direction level
		local result = ""
		if (linkz+links > 0) and (splits == 0) then
			result = result.."data "..name.."A"..chain[structs][1].."X"..chain[structs][2]
			result = result.." = "..name.."A"..chain[structs][1].."X"..chain[structs][2]
			result = result.." -- "..showPlaid(struct[index][3],all).."\n"
		end
		if (chains == 1) and (splits == 0) then
			result = result..showIndent(1)..showStructHsF(struct[index]).." -- "..struct[index][1].."\n"
		end
		if (linkz-links > 0) and (splits == 0) then
			result = result..showIndent(1).."deriving (Eq)\n"
		end
		if (linkz-links > 0) then
			structs = structs + 1
		end
		return result
	end)
	local unions = 1
	structs = 1
	result = result..stringStruct(struct,chain,split,
		function(index,linkz,stepz,links,steps,chains,splits)
		-- index transition direction level
		local result = ""
		if (stepz+steps > 0) then
			result = result.."data "..name.."A"..split[unions][1].."X"..split[unions][2].." =\n"
		end
		if (splits == 1) then
			if (linkz+links > 0) then
				result = result..showIndent(1)..name.."A"..split[unions][1].."X"..split[unions][2]
				result = result.."B"..chain[structs][1].."X"..chain[structs][2]
				result = result.." -- "..showPlaid(struct[index][3],all).."\n"
			end
			if (chains == 1) and (linkz-links <= 0) then
				result = result..showIndent(2)..showStructHsF(struct[index]).." -- "..struct[index][1].."\n"
			end
			if (chains == 1) and (linkz-links > 0) then
				result = result..showIndent(2)..showStructHsF(struct[index]).." | -- "..struct[index][1].."\n"
			end
			if (chains == 0) then
				result = result..showIndent(1)..name.."A"..split[unions][1].."X"..split[unions][2]
				result = result.."B"..index
				result = result.." "..showStructHsF(struct[index]).." | -- "..struct[index][1]
				result = result.." -- "..showPlaid(struct[index][3],all).."\n"
			end
		end
		if (stepz-steps > 0) then
			result = result..showIndent(1)..name.."A"..split[unions][1].."X"..split[unions][2]
			result = result.."Bs deriving (Eq)\n"
			unions = unions + 1
		end
		if (linkz-links > 0) then
			structs = structs + 1
		end
		return result
	end)
	result = result.."data "..name.." = "..name.."\n"
	unions = 1
	structs = 1
	result = result..stringStruct(struct,chain,split,
		function(index,linkz,stepz,links,steps,chains,splits)
		-- index transition direction level
		local result = ""
		if (linkz+links > 0) and (splits == 0) then
			result = result..showIndent(1)..name.."A"..chain[structs][1].."X"..chain[structs][2].."\n"
		end
		if (linkz+links > 0) then
			structs = structs + 1
		end
		if (stepz+steps > 0) then
			result = result..showIndent(1)..name.."A"..split[unions][1].."X"..split[unions][2].."\n"
			unions = unions + 1
		end
		if (chains == 0) and (splits == 0) then
			result = result..showIndent(1)..showStructHsF(struct[index]).." -- "..struct[index][1].."\n"
		end
		return result
	end)
	result = result..showIndent(1).."deriving (Eq)\n"
	result = result.."--"
	return result
end
function showAccessHsF(index,field,name,tree)
	local result = ""
	local branch = 1
	while (tree[branch]) do
		local leaf = " a"..tree[branch][1]
		local node = " a"..tree[branch][1].."x"..tree[branch][2]
		if (tree[branch][3] == "field") and (tree[branch][1] == index) then
			result = result.." "..field
		end
		if (tree[branch][3] == "field") and (tree[branch][1] ~= index) then
			result = result..leaf
		end
		if (tree[branch][3] == "struct") and (tree[branch][1] <= index) and (tree[branch][2] >= index) then
			result = result.." ("..name.."A"..tree[branch][1].."X"..tree[branch][2]
			result = result..showAccessHsF(index,field,name,tree[branch][4])..")"
		end
		if (tree[branch][3] == "struct") and not ((tree[branch][1] <= index) and (tree[branch][2] >= index)) then
			result = result..node
		end
		if (tree[branch][3] == "union") and (tree[branch][1] <= index) and (tree[branch][2] >= index) then
			local extend = "A"..tree[branch][1].."X"..tree[branch][2]
			result = result..showAccessHsG(index,field,name,tree[branch][4],extend)
		end
		if (tree[branch][3] == "union") and not ((tree[branch][1] <= index) and (tree[branch][2] >= index)) then
			result = result..node
		end
		branch = branch + 1
	end
	return result
end
function showAccessHsG(index,field,name,tree,extend)
	local result = ""
	local branch = 1
	while (tree[branch]) do
		local clip = "B"..tree[branch][1]
		local trim = "B"..tree[branch][1].."X"..tree[branch][2]
		if (tree[branch][3] == "field") and (tree[branch][1] == index) then
			result = result.." ("..name..extend..clip.." "..field..")"
		end
		if (tree[branch][3] == "struct") and (tree[branch][1] <= index) and (tree[branch][2] >= index) then
			result = result.." ("..name..extend
			result = result..trim..showAccessHsF(index,field,name,tree[branch][4],nil)..")"
		end
		branch = branch + 1
	end
	return result
end
function showAccessHs(name,struct)
	local chain = nestStruct(chainStruct(struct))
	local split = flatStruct(chain,nestStruct(splitStruct(struct)),condStruct(struct))
	local tree = treeStruct(#struct+1,chain,split,1,1,1)
	local result = ""
	for k,v in ipairs(struct) do
		result = result.."get"..name.."C"..v[1].." :: "
		result = result..name.." -> "..showStructHsF(v).."\n"
		result = result.."get"..name.."C"..v[1].." ("..name
		result = result..showAccessHsF(k,"a",name,tree)
		result = result..") = a\n"
	end
	result = result.."--\n"
	for k,v in ipairs(struct) do
		result = result.."set"..name.."C"..v[1].." :: "
		result = result..name.." -> "..showStructHsF(v).." -> "..name.."\n"
		result = result.."set"..name.."C"..v[1].." ("..name
		result = result..showAccessHsF(k,"_",name,tree)
		result = result..") a = ("..name
		result = result..showAccessHsF(k,"a",name,tree)
		result = result..")\n"
	end
	result = result.."--"
	return result
end
function showHelpHs()
	local result = ""
	result = result.."listHelp :: Int -> IO a -> IO [a]\n"
	result = result.."listHelp 0 b = return []\n"
	result = result.."listHelp a b = do\n"
	result = result..showIndent(1).."d <- b\n"
	result = result..showIndent(1).."e <- listHelp (a-1) b\n"
	result = result..showIndent(1).."return (d:e)\n"
	result = result.."assertHelp :: Int -> (a -> IO ()) -> [a] -> IO ()\n"
	result = result.."assertHelp a _ []\n"
	result = result..showIndent(1).."| a == 0 = return ()\n"
	result = result..showIndent(1).."| otherwise = undefined\n"
	result = result.."assertHelp a f (b:c)\n"
	result = result..showIndent(1).."| a > 0 = (f b) >> (assertHelp (a-1) f c)\n"
	result = result..showIndent(1).."| otherwise = undefined\n"
	result = result.."condHelp :: Bool -> a -> IO a -> IO a\n"
	result = result.."condHelp True _ a = a\n"
	result = result.."condHelp False a _ = return a\n"
	result = result.."firstHelp :: Eq a => a -> [a] -> IO a\n"
	result = result.."firstHelp a [] = return a\n"
	result = result.."firstHelp a (b:c)\n"
	result = result..showIndent(1).."| a == b = firstHelp a c\n"
	result = result..showIndent(1).."| otherwise = return b\n"
	result = result.."--"
	return result
end
function showCondHs(struct,dset)
	local cond = ""
	local terms = 0
	for i,dim in ipairs(listSort(dset)) do
		local set = dset[dim]
		local term = ""
		local factors = 0
		for idx,fld in ipairs(struct) do
			if (fld[1] == dim) then
				for j,val in ipairs(listSort(set)) do
					local factor = "a"..idx.." == "..val
					if (factors > 0) then term = term.." || " end
					term = term.."("..factor..")"
					factors = factors + 1
				end
			end
		end
		if (terms > 0) then cond = cond.." && " end
		if (factors > 1) then
			cond = cond.."("..term..")"
		else
			cond = cond..term
		end
		terms = terms + 1
	end
	if (terms == 0) then
		cond = "True"
	elseif (terms > 1) then
		cond = "("..cond..")"
	end
	return cond
end
function showReadHsF(name,struct,node,depth)
	local result = ""
	if (node[3] == "field") then
		result = result..showReadHsG(struct,node[1],depth)
	end
	if (node[3] == "struct") then
		result = result..showReadHsH(name,struct,node,depth)
	end
	if (node[3] == "union") then
		result = result..showReadHsI(name,struct,node,depth)
	end
	return result
end
function showReadHsG(struct,index,depth)
	local result = ""
	local field = struct[index]
	result = result..showIndent(depth).."a"..index.." <- "
	local count = 0
	if (type(field[4]) == "table") then
		while (count < #field[4]) do
			count = count + 1
			result = result.."listHelp "..field[4][count].." ("
		end
	end
	if (type(field[4]) == "string") then
		local found = "0"
		for k,v in ipairs(struct) do
			if (v[1] == field[4]) then found = "a"..k end
		end
		result = result.."listHelp "..found.." ("
		count = count + 1
	end
	if (type(field[4]) == "number") then
		result = result.."listHelp "..field[4].." ("
		count = count + 1
	end
	if (field[2] == "Str") then
		result = result.."fmap fst (readStr"
		count = count + 1
	else result = result.."read"..field[2] end
	result = result.." idx"
	while (count > 0) do
		result = result..")"
		count = count - 1
	end
	result = result.."\n"
	return result
end
function showReadHsH(name,struct,node,depth)
	local result = ""
	local args = ""
	local tree = node[4]
	local branch = 1
	while (tree[branch]) do
		local temp = tree[branch]
		local arg = "a"..temp[1]
		if (temp[3] ~= "field") then arg = arg.."x"..temp[2] end
		args = args.." "..arg
		result = result..showReadHsF(name,struct,temp,depth)
		branch = branch + 1
	end
	if (node[3] == "top") then
		result = result..showIndent(depth).."return ("..name..args..")\n"
	else
		result = result..showIndent(depth).."a"..node[1].."x"..node[2]
		result = result.." <- return ("..name.."A"..node[1].."X"..node[2]..args..")\n"
	end
	return result
end
function showReadHsI(name,struct,node,depth)
	local result = ""
	local none = name.."A"..node[1].."X"..node[2].."Bs"
	local args = ""
	local tree = node[4]
	local branch = 1
	while (tree[branch]) do
		local temp = tree[branch]
		local func = name.."A"..node[1].."X"..node[2].."B"..temp[1]
		if (temp[3] ~= "field") then func = func.."X"..temp[2] end
		local arg = "b"..temp[1]
		if (temp[3] ~= "field") then arg = arg.."x"..temp[2] end
		if (args ~= "") then args = args.."," end
		args = args..arg
		result = result..showIndent(depth)..arg.." <- condHelp "
		result = result..showCondHs(struct,struct[temp[1]][3])
		result = result.." "..none.." (do\n"
		result = result..showReadHsJ(func,struct,temp,depth+1)
		branch = branch + 1
	end
	result = result..showIndent(depth).."a"..node[1].."x"..node[2]
	result = result.." <- firstHelp "..none.." ["..args.."]\n"
	return result
end
function showReadHsJ(func,struct,node,depth)
	local result = ""
	local tree = node[4]
	if (node[3] == "field") then tree = {node} end
	local args = ""
	local branch = 1
	while (tree[branch]) do
		local temp = tree[branch]
		local arg = "a"..temp[1]
		if (args ~= "") then args = args.." " end
		args = args..arg
		result = result..showReadHsG(struct,temp[1],depth)
		branch = branch + 1
	end
	result = result..showIndent(depth).."return ("..func.." "..args.."))\n"
	return result
end
function showReadHs(name,struct)
	local chain = nestStruct(chainStruct(struct))
	local split = flatStruct(chain,nestStruct(splitStruct(struct)),condStruct(struct))
	local tree = treeStruct(#struct+1,chain,split,1,1,1)
	local result = ""
	result = result.."read"..name.." :: Int -> IO "..name.."\n"
	result = result.."read"..name.." idx = do\n"
	result = result..showReadHsH(name,struct,{1,#struct,"top",tree},1)
	result = result.."--"
	return result
end
function showWriteHsF(name,struct,tree)
	local result = ""
	local branch = 1
	while (tree[branch]) do
		local node = tree[branch]
		if (node[3] == "field") then
			result = result.." a"..node[1]
		end
		if (node[3] == "struct") then
			result = result.." ("..name.."A"..node[1].."X"..node[2]
			result = result..showWriteHsF(name,struct,node[4])
			result = result..")"
		end
		if (node[3] == "union") then
			result = result.." a"..node[1].."x"..node[2]
		end
		branch = branch + 1
	end
	return result
end
function showWriteHsG(name,struct,tree,depth)
	local result = ""
	local branch = 1
	while (tree[branch]) do
		local node = tree[branch]
		if (node[3] == "field") then
			result = result..showIndent(depth)
			result = result..showWriteHsH(struct,node[1])
		end
		if (node[3] == "struct") then
			result = result..showWriteHsG(name,struct,node[4],depth)
		end
		if (node[3] == "union") then
			result = result..showWriteHsI(name,struct,node,depth)
		end
		branch = branch + 1
		if (tree[branch]) then
			result = result.."\n"
		end
	end
	return result
end
function showWriteHsH(struct,index)
	local result = ""
	local field = struct[index]
	local count = 0
	if (type(field[4]) == "table") and (#field[4] ~= 0) then
		while (count < #field[4]) do
			count = count + 1
			result = result.."assertHelp "..field[4][count].." ("
		end
	end
	if (type(field[4]) == "string") then
		local found = "0"
		for k,v in ipairs(struct) do
			if (v[1] == field[4]) then found = "a"..k end
		end
		result = result.."assertHelp "..found.." ("
		count = count + 1
	end
	if (type(field[4]) == "number") then
		result = result.."assertHelp "..field[4].." ("
		count = count + 1
	end
	local anon = false
	if (count > 0) then
		anon = true
		result = result.."\\x -> "
	end
	result = result.."write"..field[2]
	if anon and (field[2] == "Old") then
		result = result.." x"
	elseif anon and (field[2] ~= "Old") then
		result = result.." x"
	elseif not anon and (field[2] == "Old") then
		result = result.." a"..index
	elseif not anon and (field[2] ~= "Old") then
		result = result.." a"..index
	end
	if (field[2] == "Str") then result = result.." True" end
	result = result.." idx"
	while (count > 0) do
		result = result..")"
		count = count - 1
	end
	if anon then
		result = result.." a"..index
	end
	return result
end
function showWriteHsI(name,struct,given,depth)
	local result = ""
	local tree = given[4]
	local branch = 1
	while (tree[branch]) do
		local node = tree[branch]
		result = result..showIndent(depth).."condHelp "
		result = result..showCondHs(struct,struct[node[1]][3])
		result = result.." () ((\\("..name.."A"..given[1].."X"..given[2]
		result = result.."B"..node[1]
		if (node[3] == "field") then
			result = result..showWriteHsF(name,struct,{node})
			result = result..") -> "
			result = result..showWriteHsH(struct,node[1])
		else
			result = result.."X"..node[2]
			result = result..showWriteHsF(name,struct,node[4])
			result = result..") -> do\n"
			result = result..showWriteHsG(name,struct,node[4],depth+1)
		end
		result = result..") a"..given[1].."x"..given[2]..")"
		branch = branch + 1
		if (tree[branch]) then
			result = result.."\n"
		end
	end
	return result
end
function showWriteHs(name,struct)
	local chain = nestStruct(chainStruct(struct))
	local split = flatStruct(chain,nestStruct(splitStruct(struct)),condStruct(struct))
	local tree = treeStruct(#struct+1,chain,split,1,1,1)
	local result = ""
	result = result.."write"..name.." :: "..name.." -> Int -> IO ()\n"
	result = result.."write"..name.." ("..name
	result = result..showWriteHsF(name,struct,tree)
	result = result..") idx = do\n"
	result = result..showWriteHsG(name,struct,tree,1).."\n"
	result = result.."--"
	return result
end
function showCastLua(name,enum)
	local result = ""
	result = result.."function cast"..name.."(val)\n"
	for key,val in ipairs(enum) do
		if (key == 1) then
			result = result..showIndent(1).."if (val == \""..val.."\") then return "..(key-1).."\n"
		else
			result = result..showIndent(1).."elseif (val == \""..val.."\") then return "..(key-1).."\n"
		end
	end
	result = result..showIndent(1).."else return nil end\n"
	result = result.."end"
	return result
end
function showCodeLua(name,enum)
	local result = ""
	result = result.."function read"..name.."(idx)\n"
	result = result..showIndent(1).."val = readInt(idx)\n"
	for key,val in ipairs(enum) do
		if (key == 1) then
			result = result..showIndent(1).."if (val == 0) then return \""..val.."\"\n"
		else
			result = result..showIndent(1).."elseif (val == "..(key-1)..") then return \""..val.."\"\n"
		end
	end
	result = result..showIndent(1).."else return nil end\n"
	result = result.."end\n"
	result = result.."function write"..name.."(val,idx)\n"
	for key,val in ipairs(enum) do
		if (key == 1) then
			result = result..showIndent(1).."if (val == \""..val.."\") then writeInt(0,idx)\n"
		else
			result = result..showIndent(1).."elseif (val == \""..val.."\") then writeInt("..(key-1)..",idx)\n"
		end
	end
	result = result..showIndent(1).."else writeInt("..(#enum+1)..",idx) end\n"
	result = result.."end\n"
	result = result.."--"
	return result
end
function showCondLua(struct,dset)
	local cond = ""
	local terms = 0
	for i,dim in ipairs(listSort(dset)) do
		local set = dset[dim]
		local term = ""
		local factors = 0
		for idx,fld in ipairs(struct) do
			if (fld[1] == dim) then
				for j,val in ipairs(listSort(set)) do
					local factor = "tab"..show(".","[\"")..struct[idx][1]..show("","\"]").." == "..show(struct[idx][2].."."..val,"\""..val.."\"")
					if (factors > 0) then term = term..show(" || "," or ") end
					term = term.."("..factor..")"
					factors = factors + 1
				end
			end
		end
		if (terms > 0 and language) then cond = cond.." && "
		elseif (terms > 0) then cond = cond.." and " end
		if (factors > 1) then
			cond = cond.."("..term..")"
		else
			cond = cond..term
		end
		terms = terms + 1
	end
	if (terms == 0) then
		cond = "True"
	elseif (terms > 1) then
		cond = "("..cond..")"
	end
	return cond
end
function showReadLuaF(limit,count,name)
	local result = ""
	if (count > 1) then
		result = result..".append("
	else
		result = result.." = "
	end
	local pre = ""
	local post = ""
	local index = count
	while (index <= limit) do
		pre = pre.."["
		index = index + 1
	end
	index = count
	while (index <= limit) do
		post = post.."]"
		index = index + 1
	end
	result = result..showStructHsG(name,pre,post).."()"
	if (count > 1) then
		result = result..")"
	end
	return result
end
nest = 0
function showReadLuaG(count)
	local result = ""
	if (count > nest) then
		result = "var"
	end
	if (count ~= nest) then
		nest = count
	end
	return result
end
function show(left,right)
	if language then return left else return right end
end
function showReadLua(name,struct)
	nest = 0
	local result = ""
	if language then
		result = result.."func".." read"..name.."(_ idx: CInt) -> "..name.." {\n"
		result = result..showIndent(1).."var tab = "..name.."()\n"
	else
		result = result.."function".." read"..name.."(idx)\n"
		result = result..showIndent(1).."local tab = {}\n"
	end
	for index,field in ipairs(struct) do
		local count = 0
		local conds = 0
		local cond = showCondLua(struct,field[3])
		if (cond ~= "True") then
			count = count + 1
			conds = conds + 1
			result = result..showIndent(count).."if "..cond.." "..show("{","then").."\n"
		end
		local sub = ""
		local sup = ""
		local super = false
		if (type(field[4]) == "table") then
			local squares = 1
			local square = 1
			local limit = count + #field[4]
			local dimen = 0
			while (count < limit) do
				count = count + 1
				dimen = dimen + 1
				result = result..showIndent(count).."tab"..show(".","[\"")..field[1]..show("","\"]")
				local index = square
				if language then squares = squares-1 end
				while (index < squares) do
					result = result.."[i"..index.."]"
					index = index + 1
				end
				result = result..show(showReadLuaF(limit,count,field[2])," = {}").."\n"
				squares = squares + 1
				result = result..showIndent(count)..show(showReadLuaG(count),"local").." i"..count.." = "..show("0","1").."\n"
				result = result..showIndent(count).."while (i"..count..show(" < "," <= ")..field[4][dimen]..") "..show("{","do").."\n"
				sub = sub.."[i"..count.."]"
				if (count < limit) then sup = sup.."[i"..count.."]" end
				super = true
			end
		end
		if (type(field[4]) == "string") then
			local found = "0"
			for k,v in ipairs(struct) do
				if (v[1] == field[4]) then found = "a"..k end
			end
			count = count + 1
			result = result..showIndent(count).."tab"..show(".","[\"")..field[1]..show("","\"]")..show(showReadLuaF(1,1,field[2])," = {}").."\n"
			result = result..showIndent(count)..show(showReadLuaG(count),"local").." i"..count.." = "..show("0","1").."\n"
			result = result..showIndent(count).."while (i"..count..show(" < "," <= ").."tab"..show(".","[\"")..field[4]..show("","\"]")..") "..show("{","do").."\n"
			sub = sub.."[i"..count.."]"
			super = true
		end
		if (type(field[4]) == "number") then
			count = count + 1
			result = result..showIndent(count).."tab"..show(".","[\"")..field[1]..show("","\"]")..show(showReadLuaF(1,1,field[2])," = {}").."\n"
			result = result..showIndent(count)..show(showReadLuaG(count),"local").." i"..count.." = "..show("0","1").."\n"
			result = result..showIndent(count).."while (i"..count..show(" < "," <= ")..field[4]..") "..show("{","do").."\n"
			sub = sub.."[i"..count.."]"
			super = true
		end
		result = result..showIndent(count+1).."tab"..show(".","[\"")..field[1]..show("","\"]")
		if language and super then result = result..sup..".append(" else result = result..sub.." = " end
		if (field[2] == "Chr") and language then result = result.."Character(UnicodeScalar(UInt8(readChr(idx))))"
		elseif (field[2] == "Str") and language then result = result.."callReadStr(idx)"
		else result = result.."read"..field[2].."(idx)" end
		if language and super then result = result..")" end
		if (cond ~= "True") then nest = 1 end
		result = result.."\n"
		while (count > 0) do
			if (count > conds) then
				result = result..showIndent(count+1).."i"..count.." = i"..count.." + 1\n"
			end
			result = result..showIndent(count)..show("}","end").."\n"
			count = count - 1
		end
	end
	result = result..showIndent(1).."return tab\n"
	result = result..show("}","end").."\n"
	result = result..show("//","--")
	return result
end
function showWriteLua(name,struct)
	nest = 0
	local result = ""
	if language then
		result = result.."func write"..name.."(_ tab: "..name..", _ idx: CInt) {\n"
	else
		result = result.."function write"..name.."(tab,idx)\n"
	end
	for index,field in ipairs(struct) do
		local count = 0
		local conds = 0
		local cond = showCondLua(struct,field[3])
		if (cond ~= "True") then
			count = count + 1
			conds = conds + 1
			result = result..showIndent(count).."if "..cond.." "..show("{","then").."\n"
		end
		local sub = ""
		if (type(field[4]) == "table") then
			while (count < #field[4]) do
				count = count + 1
				result = result..showIndent(count)..show(showReadLuaG(count),"local").." i"..count.." = "..show("0","1").."\n"
				result = result..showIndent(count).."while (i"..count..show(" < "," <= ")..field[4][count]..") "..show("{","do").."\n"
				sub = sub.."[i"..count.."]"
			end
		end
		if (type(field[4]) == "string") then
			local found = "0"
			for k,v in ipairs(struct) do
				if (v[1] == field[4]) then found = "a"..k end
			end
			count = count + 1
			result = result..showIndent(count)..show(showReadLuaG(count),"local").." i"..count.." = "..show("0","1").."\n"
			result = result..showIndent(count).."while (i"..count..show(" < "," <= ").."tab"..show(".","[\"")..field[4]..show("","\"]")..") "..show("{","do").."\n"
			sub = sub.."[i"..count.."]"
		end
		if (type(field[4]) == "number") then
			count = count + 1
			result = result..showIndent(count)..show(showReadLuaG(count),"local").." i"..count.." = "..show("0","1").."\n"
			result = result..showIndent(count).."while (i"..count..show(" < "," <= ")..field[4]..") "..show("{","do").."\n"
			sub = sub.."[i"..count.."]"
		end
		local value = "tab"..show(".","[\"")..field[1]..show("","\"]")..sub
		result = result..showIndent(count+1)
		if (field[2] == "Chr") and language then result = result.."writeChr(Int8("..value..".asciiValue!),idx)"
		elseif (field[2] == "Str") then result = result.."writeStr("..value..",1,idx)"
		else result = result.."write"..field[2].."("..value..",idx)" end
		if (cond ~= "True") then nest = 1 end
		result = result.."\n"
		while (count > 0) do
			if (count > conds) then
				result = result..showIndent(count+1).."i"..count.." = i"..count.." + 1\n"
			end
			result = result..showIndent(count)..show("}","end").."\n"
			count = count - 1
		end
	end
	result = result..show("}","end").."\n"
	result = result..show("//","--")
	return result
end
function showEnumSw(name,enum)
	local result = "enum "..name..": CInt {\n"
	for key,val in ipairs(enum) do
		result = result..showIndent(1).."case "..val.."\n"
	end
	result = result..showIndent(1).."case "..name.."s\n"
	result = result.."}\n"
	return result.."//"
end
function showCodeSw(name,enum)
	local result = ""
	result = result.."func read"..name.."(_ idx: CInt) -> "..name.." {"..name.."(rawValue: readInt(idx))!}\n"
	result = result.."func write"..name.."(_ val: "..name..", _ idx: CInt) {writeInt(val.rawValue, idx);}\n"
	result = result.."//"
	return result
end
function showStructSw(name,struct)
	local result = "struct "..name.." {\n"
	for key,val in ipairs(struct) do
		result = result..showIndent(1).."var "..val[1]..": "..showStructHsF(val).."!\n"
	end
	result = result.."}\n"
	return result.."//"
end
function helpStrSw()
	local result = ""
	result = result.."var capturedStr: String = \"\"\n"
	result = result.."func callReadStr(_ idx: CInt) -> String {\n"
	result = result..showIndent(1).."readStrHs({(str,trm) -> () in\n"
	result = result..showIndent(1).."capturedStr = String(cString: str!)}, idx);\n"
	result = result..showIndent(1).."return capturedStr\n"
	result = result.."}\n"
	result = result.."//"
	return result
end
function listHere(name,file)
	local list = {}
	local map = {}
	local found = false
	for line in io.lines(file) do
		local set = false
		local clear = false
		if (string.find(line,"^--HERE "..name)) then set = true
		elseif (string.find(line,"^--HERE")) then clear = true end
		if clear then found = false end
		if found then
			local match
			_, _, match = string.find(line,"([A-Za-z0-9]+) = {")
			if (match) then
				list[#list+1] = match
				map[match] = _G[match]
			end
		end
		if set then found = true end
	end
	return list,map
end
function showCall(list,map,func)
	local result = ""
	for k,v in ipairs(list) do
		if result ~= "" then result = result.."\n" end
		result = result..func(v,map[v])
	end
	return result
end
function showFuncC()
	local result = ""
	result = result..showCall(Enums,Enumz,showAllocC).."\n"
	result = result..showCall(Enums,Enumz,showShowC).."\n"
	result = result..showCall(Enums,Enumz,showHideC).."\n"
	for k,v in ipairs(Enums) do luaxSide(showCastLua(v,Enumz[v])) end
	result = result..showCall(Constants,Constantz,showConstantC).."\n"
	result = result..showCall(Structs,Structz,showOffsetC).."\n"
	result = result..showCall(Structs,Structz,showFreeC).."\n"
	result = result..showCall(Structs,Structz,showAllocC).."\n"
	result = result..showCall(Structs,Structz,showReadC).."\n"
	result = result..showCall(Structs,Structz,showWriteC).."\n"
	result = result..showCall(Structs,Structz,showRandC).."\n"
	result = result..showCall(Structs,Structz,showCompC).."\n"
	result = result..showCall(Structs,Structz,showSizeC).."\n"
	result = result..showCall(Structs,Structz,showShowC).."\n"
	result = result..showCall(Structs,Structz,showHideC).."\n"
	result = result..showRstructC(Structs).."\n"
	result = result..showWstructC(Structs).."\n"
	result = result..showIstructC(Structs)
	return result
end
function showCallH()
	local result = ""
	result = result..showCall(Enums,Enumz,showEnumC).."\n"
	result = result..showCall(Structs,Structz,showStructC).."\n"
	prototype = true
	result = result..showFuncC()
	return result
end
function showCallC()
	local result = ""
	prototype = false
	result = result..showFuncC()
	return result
end
function showCallHs()
	local result = ""
	language = false
	result = result..showCall(Enums,Enumz,showEnumHs).."\n"
	result = result..showCall(Enums,Enumz,showCodeHs).."\n"
	result = result..showCall(Structs,Structz,showStructHs).."\n"
	result = result..showCall(Structs,Structz,showAccessHs).."\n"
	result = result..showHelpHs().."\n"
	result = result..showCall(Structs,Structz,showReadHs).."\n"
	result = result..showCall(Structs,Structz,showWriteHs)
	return result
end
function showCallLua()
	local result = ""
	language = false
	result = result..showCall(Enums,Enumz,showCodeLua).."\n"
	result = result..showCall(Enums,Enumz,showCastLua).."\n"
	result = result..showCall(Structs,Structz,showReadLua).."\n"
	result = result..showCall(Structs,Structz,showWriteLua)
	return result
end
function showCallSw()
	local result = ""
	language = true
	result = result..showCall(Enums,Enumz,showEnumSw).."\n"
	result = result..showCall(Enums,Enumz,showCodeSw).."\n"
	result = result..showCall(Structs,Structz,showStructSw).."\n"
	result = result..helpStrSw().."\n"
	result = result..showCall(Structs,Structz,showReadLua).."\n"
	result = result..showCall(Structs,Structz,showWriteLua)
	return result
end
