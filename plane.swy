import type
import plane
import face
import AppKit
import Metal

var device:MTLDevice!
var layer:CAMetalLayer!
var view:NSView!
var window:NSWindow!
var queue:MTLCommandQueue!
var render = [MTLRenderPipelineState?](repeating: nil, count: Int(Shaders.rawValue))
var param = [MTLRenderPassDescriptor?](repeating: nil, count: Int(Shaders.rawValue))
var depth = [MTLDepthStencilState?](repeating: nil, count: Int(Shaders.rawValue))
var compute = [MTLComputePipelineState?](repeating: nil, count: Int(Shaders.rawValue))
var threads = [MTLSize?](repeating: nil, count: Int(Shaders.rawValue))

var lock = [Refer]()
var count = Int(0)
let event = getEvent()
var running = Int(0)

var triangle = Pend<Triangle>()
var numeric = Pend<Numeric>()
var vertex = Pend<Vertex>()
var subject = Pend<Matrix>()
var object = Pend<Matrix>()
var element = Pend<Matrix>()
var swarm = Pend<Vector>()
var texture = Pend<Vector>()
var basis = Pend<Basis>()
var uniform = Pend<Uniform>()
var pierce = Pend<Pierce>()
var array = [Slice]()

class Refer
{
	var lock:Int = 0
}
func toMutable<T>(_ list:[T], _ fnc:(_:Int,_:UnsafeMutablePointer<T>)->Void)
{
	let ptr = UnsafeMutablePointer<T>.allocate(capacity:list.count)
	for (val,idx) in zip(list,Swift.Array(0..<list.count)) {ptr[idx] = val}
	fnc(list.count,ptr)
	ptr.deallocate()
}
func toArray<T>(_ list: [T], _ vals: [T], _ index: Int, _ limit: Int) -> [T]
{
	var result = list
	var todo = vals.count
	var done = 0
	var idx = index%limit
	var bas = 0
	if (idx > result.count) {
		todo = todo + idx - result.count
		bas = (vals.count - (idx - result.count) % vals.count) % vals.count
	}
	while (done < todo) {
		var lim = vals.count
		if (idx + lim - bas > limit) {
			lim = limit - idx + bas
		}
		if (idx < result.count && idx + lim - bas > result.count) {
			lim = result.count - idx + bas
		}
		if (idx < result.count) {
			result[idx...(idx+lim-bas - 1)] = vals[bas...(lim-1)]
		} else {
			result.append(contentsOf:vals[bas...(lim-1)])
		}
		done = done + lim - bas
		idx = (idx + lim - bas) % limit
		bas = lim % vals.count
	}
	return result
}
class Pend<T>
{
	var pend:MTLBuffer!
	var last:MTLBuffer!
	var refer:Refer!
	func set(_ ptr: UnsafeRawPointer, _ range: Range<Int>)
	{
		let len:Int = range.upperBound
		let unit:Int = MemoryLayout<T>.size
		let length:Int = len+(unit-len%unit)%unit;
		if (pend == nil && last != nil && last.length < length) {
			pend = device.makeBuffer(length:length)
			pend.contents().copyMemory(from:last.contents(),byteCount:last.length)
			last = nil
		}
		if (pend == nil && last != nil && refer.lock == 0)
		{
			pend = last
			last = nil
		}
		if (pend == nil && last != nil) {
			pend = device.makeBuffer(bytes:last.contents(),length:last.length)
			last = nil
		}
		if (pend == nil) {
			pend = device.makeBuffer(length:length)
		}
		if (pend != nil) {
			let base:Int = range.lowerBound
			let size:Int = range.upperBound-range.lowerBound
			pend.contents().advanced(by:base).copyMemory(from:ptr,byteCount:size)
		}
	}
	func set(_ vals: [T], _ index: Int)
	{
		let siz = MemoryLayout<T>.size
		let base = siz*index
		let limit = base+siz*vals.count
		toMutable(vals) {(len,ptr) in
		set(UnsafePointer<T>(ptr),base..<limit)}
	}
	func set(_ vals:[T], _ index: Int, _ length : Int)
	{
		var sub = 0
		var idx = index%length
		while (vals.count-sub > length) {
			set(Array(vals[sub...(sub+length-idx-1)]),idx)
			sub = sub + length - idx; idx = 0}
		set(Array(vals[sub...(vals.count-1)]),idx)
	}
	func set(_ val: [T]?, _ index: Int)
	{
		guard let vals = val else {return}
		set(vals,index)
	}
	func set<S>(_ val: S, _ field: PartialKeyPath<T>)
	{
		guard let fld = MemoryLayout<T>.offset(of:field) else {exitErr(#file,#line);return}
		let siz = MemoryLayout<S>.size
		toMutable([val]) {(len,ptr) in
		set(UnsafePointer<S>(ptr),fld..<fld+siz)}
	}
	func get() -> MTLBuffer
	{
		if (last == nil && pend != nil) {
			refer = Refer()
			last = pend
			pend = nil
		}
		if (last != nil) {
			lock.append(refer)
			refer.lock += 1
		}
		return last
	}
}
func getTexture(_ rect:NSRect) -> MTLTexture?
{
	let text = MTLTextureDescriptor()
	text.height = Int(rect.height)
	text.width = Int(rect.width)
	text.pixelFormat = .depth32Float
	text.storageMode = .private
	return device.makeTexture(descriptor:text)
}
func getLock() -> MTLCommandBufferHandler
{
	let temp = lock
	lock = []
	return {(MTLCommandBuffer) in for ref in temp {ref.lock -= 1}}
}
func getReady() -> MTLCommandBufferHandler
{
	let index = Int32(planeConfig(PierceIndex))
	let limit = Int32(planeConfig(PierceLimit))
	if (index == limit) {return {(MTLCommandBuffer) in planeReady(nil,index,limit)}}
	let last = pierce.get()
	return {(MTLCommandBuffer) in planeReady(UnsafeMutablePointer<Pierce>(OpaquePointer(last.contents())),index,limit)}
}
func getCount() -> MTLCommandBufferHandler
{
	return {(MTLCommandBuffer) in count -= 1; planeWake(RegisterDone)}
}
class getEvent : NSObject, NSWindowDelegate
{
	func windowShouldClose(_ sender: NSWindow) -> Bool
	{
		running = 0
		NSApp.stop(nil)
		return true
	}
	func windowWillMove(_ notification: Notification)
	{
		swiftWake(WindowLeft)
	}
	func windowDidMove(_ notification: Notification)
	{
		swiftWake(WindowBase)
	}
	func windowWillResize(_ notification: Notification)
	{
		swiftWake(WindowWide)
	}
	func windowDidResize(_ notification: Notification)
	{
		swiftWake(WindowHigh)
	}
}
func setEvent(_ type:NSEvent.EventTypeMask, _ hint: Configure)
{
	NSEvent.addLocalMonitorForEvents(matching:type, handler: {(event: NSEvent) in planeWake(hint); return event})
}
func swiftInit()
{
	for arg in CommandLine.arguments {planeArgument(arg)}
	device = MTLCreateSystemDefaultDevice()
	let rect = NSMakeRect(
		CGFloat(planeConfig(WindowLeft)), CGFloat(planeConfig(WindowBase)),
		CGFloat(planeConfig(WindowWide)), CGFloat(planeConfig(WindowHigh)))
	layer = CAMetalLayer()
	layer.device = device
	layer.pixelFormat = .bgra8Unorm
	layer.framebufferOnly = true
	layer.frame = rect
	view = NSView(frame:rect)
	view.wantsLayer = true
	view.layer = layer
	let mask:NSWindow.StyleMask = [.titled, .closable, .miniaturizable, .resizable]
	window = NSWindow(contentRect: rect, styleMask: mask, backing: .buffered, defer: true)
	window.title = "plane"
	window.makeKeyAndOrderFront(nil)
	window.contentView = view
	window.delegate = event
	queue = device.makeCommandQueue()
	guard let library:MTLLibrary = try? device.makeLibrary(filepath:"planeG.so") else {
		fputs("plane: cannot load library: planeG.so\n",stderr);exitErr(#file,#line);return}
	for sub in 0...Int(Shaders.rawValue-1) {let shader = Shader(UInt32(sub)); if (shader == Dipoint || shader == Adpoint) {switch (shader) {
	case (Dipoint): fallthrough case (Diplane):
	guard let vertex_render = library.makeFunction(name:String(cString: Initial__Shader__Stage_Str(Dipoint)(Corner)!)) else {
		print("cannot make vertex_render");exitErr(#file,#line);return}
	guard let fragment_render = library.makeFunction(name:String(cString: Initial__Shader__Stage_Str(Dipoint)(Fragment)!)) else {
		print("cannot make fragment_render");exitErr(#file,#line);return}
	let pipe = MTLRenderPipelineDescriptor()
	pipe.vertexFunction = vertex_render
	pipe.fragmentFunction = fragment_render
	pipe.colorAttachments[0].pixelFormat = .bgra8Unorm
	pipe.depthAttachmentPixelFormat = .depth32Float
	render[sub] = try? device.makeRenderPipelineState(descriptor:pipe)
	let color = MTLClearColor(red: 0.0, green: 104.0/255.0, blue: 55.0/255.0, alpha: 1.0)
	param[sub] = MTLRenderPassDescriptor()
	param[sub]!.colorAttachments[0].clearColor = color
	param[sub]!.colorAttachments[0].storeAction = .store
	param[sub]!.depthAttachment.clearDepth = 0.0 // clip xy -1 to 1; z 0 to 1
	param[sub]!.depthAttachment.storeAction = .dontCare
	param[sub]!.depthAttachment.texture = getTexture(rect)
    let desc = MTLDepthStencilDescriptor()
    desc.depthCompareFunction = .greater // left hand rule; z thumb to observer
    desc.isDepthWriteEnabled = true
    depth[sub] = device.makeDepthStencilState(descriptor: desc)
    default:
	guard let kernel_pierce = library.makeFunction(name:String(cString: Initial__Shader__Str(Shader(UInt32(sub)))!)) else {
	 	print("cannot make kernel_pierce");exitErr(#file,#line);return}
	compute[sub] = try? device.makeComputePipelineState(function:kernel_pierce)
    threads[sub] = device.maxThreadsPerThreadgroup}}}
	setEvent(.keyDown,ButtonPress)
	setEvent(.keyUp,ButtonHold)
	setEvent(.leftMouseUp,ButtonDrag)
	setEvent(.rightMouseUp,ButtonDrag)
	setEvent(.leftMouseDown,ButtonClick)
	setEvent(.rightMouseDown,ButtonClick)
	setEvent(.mouseMoved,CursorLeft)
	setEvent(.scrollWheel,CursorAngle)
	NSEvent.addLocalMonitorForEvents(matching:.applicationDefined, handler: {(event: NSEvent) in planeWake(Configure(UInt32(event.data1))); return event})
}
func swiftRun()
{
	running = 1
	NSApp.run()
}
func swiftMemory(_ ptr: UnsafeMutablePointer<Center>?)
{
	let center = ptr!.pointee
	let siz = Int(center.siz)
	let idx = Int(center.idx)
	switch (center.mem) {
	case (Trianglez): triangle.set(Swift.Array(0..<siz).map() {(sub) in center.tri![sub]},idx,Int(planeConfig(TriangleSize)))
	case (Numericz): numeric.set(Swift.Array(0..<siz).map() {(sub) in center.num![sub]},idx,Int(planeConfig(NumericSize)))
	case (Vertexz): vertex.set(Swift.Array(0..<siz).map() {(sub) in center.vtx![sub]},idx,Int(planeConfig(VertexSize)))
	case (Allmatz): subject.set(Swift.Array(0..<siz).map() {(sub) in center.all![sub]},idx,Int(planeConfig(SubjectSize)))
	case (Fewmatz): object.set(Swift.Array(0..<siz).map() {(sub) in center.few![sub]},idx,Int(planeConfig(ObjectSize)))
	case (Onematz): element.set(Swift.Array(0..<siz).map() {(sub) in center.one![sub]},idx,Int(planeConfig(ElementSize)))
	case (Swarmz): swarm.set(Swift.Array(0..<siz).map() {(sub) in center.swa![sub]},idx,Int(planeConfig(SwarmSize)))
	case (Texturez): texture.set(Swift.Array(0..<siz).map() {(sub) in center.tex![sub]},idx,Int(planeConfig(TextureSize)))
	case (Basisz): basis.set(Swift.Array(0..<siz).map() {(sub) in center.bas![sub]},idx,Int(planeConfig(BasisSize)))
	case (Piercez): pierce.set(Swift.Array(repeating: Pierce(), count: siz),idx,Int(planeConfig(PierceLimit)-planeConfig(PierceIndex)))
	case (Slicez): array = toArray(array,Swift.Array(0..<siz).map() {(sub) in center.rng![sub]},idx,Int(planeConfig(SliceSize)))
	case (Configurez): for sub in Swift.Array(0..<siz) {switch center.cfg![sub] {
		case (UniformAll): uniform.set(center.val![sub],\Uniform.all)
		case (UniformOne): uniform.set(center.val![sub],\Uniform.one)
		case (UniformLeft): uniform.set(center.val![sub],\Uniform.lon)
		case (UniformBase): uniform.set(center.val![sub],\Uniform.lat)
		case (UniformIndex): uniform.set(Int(center.val![sub]),\Uniform.idx)
		case (UniformSize): uniform.set(Int(center.val![sub]),\Uniform.siz)
		case (UniformBasis): uniform.set(center.val![sub],\Uniform.bas)
		case (TriangleSize): uniform.set(Int(center.val![sub]),\Uniform.tsz)
		case (NumericSize): uniform.set(Int(center.val![sub]),\Uniform.nsz)
		case (VertexSize): uniform.set(Int(center.val![sub]),\Uniform.vsz)
		case (SubjectSize): uniform.set(Int(center.val![sub]),\Uniform.asz)
		case (ObjectSize): uniform.set(Int(center.val![sub]),\Uniform.fsz)
		case (ElementSize): uniform.set(Int(center.val![sub]),\Uniform.osz)
		case (SwarmSize): uniform.set(Int(center.val![sub]),\Uniform.ssz)
		case (TextureSize): uniform.set(Int(center.val![sub]),\Uniform.xsz)
		case (BasisSize): uniform.set(Int(center.val![sub]),\Uniform.bsz)
		case (PierceSize): uniform.set(Int(center.val![sub]),\Uniform.psz)
		case (PierceIndex): uniform.set(Int(center.val![sub]),\Uniform.pid)
		case (PierceLimit): uniform.set(Int(center.val![sub]),\Uniform.plm)
		case (RegisterOpen): running = Int(center.val![sub]); if (running == 0) {NSApp.stop(nil)}
		default: break}}
	default: exitErr(#file,#line)}
}
func swiftWake(_ hint: Configure)
{
	NSApp.postEvent(
		NSEvent.otherEvent(
		with:.applicationDefined,
		location:NSZeroPoint,
		modifierFlags:.command,
		timestamp:0.0,
		windowNumber:0,
		context:nil,
		subtype:0,
		data1:Int(hint.rawValue),
		data2:0)!,
		atStart:false)	
}
func swiftInfo(_ query: Configure) -> Int32
{
	switch (query) {
	case (RegisterDone): return Int32(count)
	case (RegisterOpen): return Int32(running)
	// TODO cursor, window, keyboard, read from uniform
	default: break}
	return 0
}
func swiftDraw(_ shader: Shader, _ start: Int32, _ stop: Int32)
{
	let sub = Int(shader.rawValue)
	switch (shader) {
	case (Dipoint): fallthrough case (Diplane):
	guard let code = queue.makeCommandBuffer() else {exitErr(#file,#line);return}
    guard let draw = layer.nextDrawable() else {exitErr(#file,#line);return}
	param[sub]!.colorAttachments[0].texture = draw.texture
	param[sub]!.colorAttachments[0].loadAction = .clear
	param[sub]!.depthAttachment.loadAction = .clear
	if (array.count == 0) {
		guard let encode = code.makeRenderCommandEncoder(descriptor:param[sub]!) else {exitErr(#file,#line);return}
		encode.endEncoding()
	}
	for range in array { // TODO use start and stop
		guard let encode = code.makeRenderCommandEncoder(descriptor:param[sub]!) else {exitErr(#file,#line);return}
		encode.setRenderPipelineState(render[sub]!)
		encode.setDepthStencilState(depth[sub]!)
		encode.setVertexBuffer(triangle.get(),offset:0,index:0)
		encode.setVertexBuffer(vertex.get(),offset:0,index:1)
		encode.setVertexBuffer(subject.get(),offset:0,index:2)
		encode.setVertexBuffer(object.get(),offset:0,index:3)
		encode.setVertexBuffer(element.get(),offset:0,index:4)
		encode.setVertexBuffer(uniform.get(),offset:0,index:5)
		encode.drawPrimitives(
			type:.triangle,
			vertexStart:Int(range.idx),
			vertexCount:Int(range.siz))
		encode.endEncoding()
		param[sub]!.colorAttachments[0].loadAction = .load
		param[sub]!.depthAttachment.loadAction = .load
	}
	code.present(draw)
	code.addScheduledHandler(getLock())
	code.addCompletedHandler(getCount())
	count += 1
	code.commit()
	default:
	guard let code = queue.makeCommandBuffer() else {exitErr(#file,#line);return}
	for range in array { // TODO use start and stop
		var offset = (Int(range.idx)*MemoryLayout<Triangle>.size)/3
		var nums:[Int] = []
		var pers:[Int] = []
		let quotient = (Int(range.siz)/threads[sub]!.width)/3
		let remainder = (Int(range.siz)%threads[sub]!.width)/3
		if (quotient > 0) {
			nums.append(quotient)
			pers.append(threads[sub]!.width)}
		if (remainder > 0) {
			nums.append(1)
			pers.append(remainder)}
		for (n,p) in zip(nums,pers) {
			guard let encode = code.makeComputeCommandEncoder() else {exitErr(#file,#line);return}
			encode.setComputePipelineState(compute[sub]!)
			encode.setBuffer(triangle.get(),offset:offset,index:0)
			encode.setBuffer(numeric.get(),offset:0,index:1)
			encode.setBuffer(vertex.get(),offset:0,index:2)
			encode.setBuffer(subject.get(),offset:0,index:3)
			encode.setBuffer(object.get(),offset:0,index:4)
			encode.setBuffer(element.get(),offset:0,index:5)
			encode.setBuffer(basis.get(),offset:0,index:6)
			encode.setBuffer(uniform.get(),offset:0,index:7)
			encode.setBuffer(pierce.get(),offset:0,index:8)
			let num = MTLSize(width:n,height:1,depth:1)
			let per = MTLSize(width:p,height:1,depth:1)
			encode.dispatchThreadgroups(num,threadsPerThreadgroup:per)
			encode.endEncoding()
			offset += n*p*MemoryLayout<Triangle>.size
		}
	}
	code.addCompletedHandler(getReady())
	code.addScheduledHandler(getLock())
	code.addCompletedHandler(getCount())
	count += 1
	code.commit()
	}
}

// MAIN

	planeInit(swiftInit,swiftRun,swiftMemory,swiftWake,swiftInfo,swiftDraw)
