import type
import plane
import face
import AppKit
import Metal

var device:MTLDevice!
var layer:CAMetalLayer!
var view:NSView!
var window:NSWindow!
var queue:MTLCommandQueue!
var render = [MTLRenderPipelineState?]()
var param = [MTLRenderPassDescriptor?]()
var depth = [MTLDepthStencilState?]()
var compute = [MTLComputePipelineState?]()
var threads = [MTLSize?]()

var lock = [Refer]()
var count = Int(0)
let event = getEvent()
var running = Int(0)

var triangle = Pend<Triangle>()
var numeric = Pend<Numeric>()
var vertex = Pend<Vertex>()
var matrix = Pend<Matrix>()
var swarm = Pend<Vector>()
var texture = Pend<Vector>()
var uniform = Pend<Uniform>()
var pierce = Pend<Pierce>()
var array = [Slice]()

class Refer
{
	var lock:Int = 0
}
func toMutable<T>(_ list:[T], _ fnc:(_:Int,_:UnsafeMutablePointer<T>)->Void)
{
	let ptr = UnsafeMutablePointer<T>.allocate(capacity:list.count)
	for (val,idx) in zip(list,Swift.Array(0..<list.count)) {ptr[idx] = val}
	fnc(list.count,ptr)
	ptr.deallocate()
}
class Pend<T>
{
	var pend:MTLBuffer!
	var last:MTLBuffer!
	var refer:Refer!
	func set(_ ptr: UnsafeRawPointer, _ range: Range<Int>)
	{
		let len:Int = range.upperBound
		let unit:Int = MemoryLayout<T>.size
		let length:Int = len+(unit-len%unit)%unit;
		if (pend == nil && last != nil && last.length < length) {
			pend = device.makeBuffer(length:length)
			pend.contents().copyMemory(from:last.contents(),byteCount:last.length)
			last = nil
		}
		if (pend == nil && last != nil && refer.lock == 0)
		{
			pend = last
			last = nil
		}
		if (pend == nil && last != nil) {
			pend = device.makeBuffer(bytes:last.contents(),length:last.length)
			last = nil
		}
		if (pend == nil) {
			pend = device.makeBuffer(length:length)
		}
		if (pend != nil) {
			let base:Int = range.lowerBound
			let size:Int = range.upperBound-range.lowerBound
			pend.contents().advanced(by:base).copyMemory(from:ptr,byteCount:size)
		}
	}
	func set(_ vals: [T], _ index: Int)
	{
		let siz = MemoryLayout<T>.size
		let base = siz*index
		let limit = base+siz*vals.count
		toMutable(vals) {(len,ptr) in
		set(UnsafePointer<T>(ptr),base..<limit)}
	}
	func set(_ vals:[T], _ index: Int, _ length : Int)
	{
		var sub = 0
		var idx = index%length
		while (vals.count-sub > length) {
			set(Array(vals[sub...(sub+length-idx-1)]),idx)
			sub = sub + length - idx; idx = 0}
		set(Array(vals[sub...(vals.count-1)]),idx)
	}
	func set(_ val: [T]?, _ index: Int)
	{
		guard let vals = val else {return}
		set(vals,index)
	}
	func set<S>(_ val: S, _ field: PartialKeyPath<T>)
	{
		guard let fld = MemoryLayout<T>.offset(of:field) else {exitErr(#file,#line,-1);return}
		let siz = MemoryLayout<S>.size
		toMutable([val]) {(len,ptr) in
		set(UnsafePointer<S>(ptr),fld..<fld+siz)}
	}
	func get() -> MTLBuffer
	{
		if (last == nil && pend != nil) {
			refer = Refer()
			last = pend
			pend = nil
		}
		if (last != nil) {
			lock.append(refer)
			refer.lock += 1
		}
		return last
	}
}
func getRect() -> NSRect
{
	if let temp = window {
		return temp.contentRect(forFrameRect:temp.frame)
	} else {
		return NSMakeRect(0.0, 0.0, 
			CGFloat(planeConfig(WindowWide)),
			CGFloat(planeConfig(WindowHigh)))
	}
}
func getPoint() -> NSPoint
{
	var point = NSEvent.mouseLocation
	let frame:CGRect = window.frame
	point.x = point.x - NSMinX(frame)
	point.y = point.y - NSMinY(frame)
	return point
}
func getTexture(_ rect:NSRect) -> MTLTexture?
{
	let text = MTLTextureDescriptor()
	text.height = Int(rect.height)
	text.width = Int(rect.width)
	text.pixelFormat = .depth32Float
	text.storageMode = .private
	return device.makeTexture(descriptor:text)
}
func getLock() -> MTLCommandBufferHandler
{
	let temp = lock
	lock = []
	return {(MTLCommandBuffer) in for ref in temp {ref.lock -= 1}}
}
func getReady() -> MTLCommandBufferHandler
{
	let index = Int32(planeConfig(PierceIndex))
	let limit = Int32(planeConfig(PierceLimit))-index
	if (index == limit) {return {(MTLCommandBuffer) in planeReady(nil,index,limit)}}
	let last = pierce.get()
	return {(MTLCommandBuffer) in planeReady(UnsafeMutablePointer<Pierce>(OpaquePointer(last.contents())),index,limit)}
}
func getCount() -> MTLCommandBufferHandler
{
	return {(MTLCommandBuffer) in count -= 1; planeWake(RegisterDone)}
}
func getThird(_ range: Slice) -> Slice
{
	var result = Slice()
	result.idx = range.idx/3
	result.siz = range.siz/3
	return result
}
class getEvent : NSObject, NSWindowDelegate
{
	func windowShouldClose(_ sender: NSWindow) -> Bool
	{
		NSApp.stop(nil)
		return true
	}
	func windowDidResize(_ notification: Notification)
	{
		// swiftSize()
	}
}
func setEvent(_ type:NSEvent.EventTypeMask, _ handler: @escaping (_:NSEvent) -> NSEvent?)
{
	NSEvent.addLocalMonitorForEvents(matching:type,handler:handler)
}
func swiftLeft(event: NSEvent) -> NSEvent?
{
	print("swiftLeft")
	planeWake(ButtonClick)
	return event
}
func swiftInit()
{
	for arg in CommandLine.arguments {planeArgument(arg)}
	device = MTLCreateSystemDefaultDevice()
	let rect = NSMakeRect(
		CGFloat(planeConfig(WindowLeft)), CGFloat(planeConfig(WindowBase)),
		CGFloat(planeConfig(WindowWide)), CGFloat(planeConfig(WindowHigh)))
	layer = CAMetalLayer()
	layer.device = device
	layer.pixelFormat = .bgra8Unorm
	layer.framebufferOnly = true
	layer.frame = rect
	view = NSView(frame:rect)
	view.wantsLayer = true
	view.layer = layer
	let mask:NSWindow.StyleMask = [.titled, .closable, .miniaturizable, .resizable]
	window = NSWindow(contentRect: rect, styleMask: mask, backing: .buffered, defer: true)
	window.title = "plane"
	window.makeKeyAndOrderFront(nil)
	window.contentView = view
	window.delegate = event
	queue = device.makeCommandQueue()
	guard let library:MTLLibrary = try? device.makeLibrary(filepath:"planeG.so") else {
		fputs("plane: cannot load library: planeG.so\n",stderr);exitErr(#file,#line,-1);return}
	for sub in 0...Int(Shaders.rawValue-1) {let shader = Shader(UInt32(sub)); if (shader == Dipoint || shader == Adpoint) {switch (Initial__Shader__Special(shader)) {
	case (Display):
	guard let vertex_render = library.makeFunction(name:String(cString: Initial__Shader__Stage_Str(Dipoint)(Corner)!)) else {
		print("cannot make vertex_render");exitErr(#file,#line,-1);return}
	guard let fragment_render = library.makeFunction(name:String(cString: Initial__Shader__Stage_Str(Dipoint)(Fragment)!)) else {
		print("cannot make fragment_render");exitErr(#file,#line,-1);return}
	let pipe = MTLRenderPipelineDescriptor()
	pipe.vertexFunction = vertex_render
	pipe.fragmentFunction = fragment_render
	pipe.colorAttachments[0].pixelFormat = .bgra8Unorm
	pipe.depthAttachmentPixelFormat = .depth32Float
	render[sub] = try? device.makeRenderPipelineState(descriptor:pipe)
	let color = MTLClearColor(red: 0.0, green: 104.0/255.0, blue: 55.0/255.0, alpha: 1.0)
	param[sub] = MTLRenderPassDescriptor()
	param[sub]!.colorAttachments[0].clearColor = color
	param[sub]!.colorAttachments[0].storeAction = .store
	param[sub]!.depthAttachment.clearDepth = 0.0 // clip xy -1 to 1; z 0 to 1
	param[sub]!.depthAttachment.storeAction = .dontCare
	param[sub]!.depthAttachment.texture = getTexture(rect)
    let desc = MTLDepthStencilDescriptor()
    desc.depthCompareFunction = .greater // left hand rule; z thumb to observer
    desc.isDepthWriteEnabled = true
    depth[sub] = device.makeDepthStencilState(descriptor: desc)
    case (Compute):
	guard let kernel_pierce = library.makeFunction(name:String(cString: Initial__Shader__Str(Shader(UInt32(sub)))!)) else {
	 	print("cannot make kernel_pierce");exitErr(#file,#line,-1);return}
	compute[sub] = try? device.makeComputePipelineState(function:kernel_pierce)
    threads[sub] = device.maxThreadsPerThreadgroup
    default: print("invalid shader type");exitErr(#file,#line,-1); return}}}
	// setEvent(.keyDown,swiftKey)
	setEvent(.leftMouseUp,swiftLeft)
	// setEvent(.rightMouseUp,swiftRight)
	// setEvent(.leftMouseDown,swiftActive)
	// setEvent(.rightMouseDown,swiftActive)
	// setEvent(.mouseMoved,swiftMove)
	// setEvent(.scrollWheel,swiftRoll)
	// setEvent(.applicationDefined,swiftCheck)
}
func swiftRun()
{
	running = 1
	NSApp.run()
	running = 0
}
func swiftMemory(_ ptr: UnsafeMutablePointer<Client>?)
{
	let client = ptr!.pointee
	let siz = Int(client.siz)
	let idx = Int(client.idx)
	switch (client.mem) {
	case (Trianglez): triangle.set(Swift.Array(0..<siz).map() {(sub) in client.tri![sub]},idx,Int(planeConfig(TriangleSize)))
	case (Numericz): numeric.set(Swift.Array(0..<siz).map() {(sub) in client.num![sub]},idx,Int(planeConfig(NumericSize)))
	case (Vertexz): vertex.set(Swift.Array(0..<siz).map() {(sub) in client.vtx![sub]},idx,Int(planeConfig(VertexSize)))
	case (Piercez): pierce.set(Swift.Array(repeating: Pierce(), count: siz),idx,Int(planeConfig(PierceSize)))
	case (Swarmz): swarm.set(Swift.Array(0..<siz).map() {(sub) in client.swa![sub]},idx,Int(planeConfig(SwarmSize)))
	case (Texturez): texture.set(Swift.Array(0..<siz).map() {(sub) in client.tex![sub]},idx,Int(planeConfig(TextureSize)))
	case (Basisz): uniform.set(client.bas![0],\Uniform.bas)
	case (Allmatz): uniform.set(client.all![0],\Uniform.all)
	case (Fewmatz): matrix.set(Swift.Array(0..<siz).map() {(sub) in client.few![sub]},idx,Int(planeConfig(ObjectSize)))
	case (Onematz): uniform.set(client.one![0],\Uniform.one)
	case (Slicez): array = Swift.Array(0..<siz).map() {(sub) in client.rng![sub]} // TODO use idx to insert into array of size planeConfig(SliceSize)
	case (Configurez): for sub in Swift.Array(0..<siz) {switch client.cfg![sub] {
		case (UniformLeft): uniform.set(client.val![sub],\Uniform.lon)
		case (UniformBase): uniform.set(client.val![sub],\Uniform.lat)
		case (UniformIndex): uniform.set(Int(client.val![sub]),\Uniform.idx)
		case (UniformSize): uniform.set(Int(client.val![sub]),\Uniform.siz)
		case (TriangleSize): uniform.set(Int(client.val![sub]),\Uniform.tsz)
		case (TriangleLimit): uniform.set(Int(client.val![sub]),\Uniform.tlm)
		case (TriangleIndex): uniform.set(Int(client.val![sub]),\Uniform.tid)
		case (NumericSize): uniform.set(Int(client.val![sub]),\Uniform.nsz)
		case (NumericLimit): uniform.set(Int(client.val![sub]),\Uniform.nlm)
		case (NumericIndex): uniform.set(Int(client.val![sub]),\Uniform.nid)
		case (VertexSize): uniform.set(Int(client.val![sub]),\Uniform.vsz)
		case (VertexLimit): uniform.set(Int(client.val![sub]),\Uniform.vlm)
		case (VertexIndex): uniform.set(Int(client.val![sub]),\Uniform.vid)
		case (PierceSize): uniform.set(Int(client.val![sub]),\Uniform.psz)
		case (PierceLimit): uniform.set(Int(client.val![sub]),\Uniform.plm)
		case (PierceIndex): uniform.set(Int(client.val![sub]),\Uniform.pid)
		case (ObjectSize): uniform.set(Int(client.val![sub]),\Uniform.osz)
		case (ObjectLimit): uniform.set(Int(client.val![sub]),\Uniform.olm)
		case (ObjectIndex): uniform.set(Int(client.val![sub]),\Uniform.oid)
		case (SwarmSize): uniform.set(Int(client.val![sub]),\Uniform.ssz)
		case (SwarmLimit): uniform.set(Int(client.val![sub]),\Uniform.slm)
		case (SwarmIndex): uniform.set(Int(client.val![sub]),\Uniform.sid)
		case (TextureSize): uniform.set(Int(client.val![sub]),\Uniform.xsz)
		case (TextureLimit): uniform.set(Int(client.val![sub]),\Uniform.xlm)
		case (TextureIndex): uniform.set(Int(client.val![sub]),\Uniform.xid)
		default: break}}
	default: exitErr(#file,#line,-1)}
}
func swiftWake(_ stop: Int32)
{
	if (stop != 0) {NSApp.stop(nil); return}
	// TODO create event
}
func swiftInfo(_ query: Configure) -> Int32
{
	switch (query) {
	case (RegisterDone): return Int32(count)
	case (RegisterOpen): return Int32(running)
	// TODO cursor, window, keyboard, read from uniform
	default: break}
	return 0
}
func swiftDraw(_ shader: Shader, _ start: Int32, _ stop: Int32)
{
	let sub = Int(shader.rawValue)
	switch (Initial__Shader__Special(shader)) {
	case (Display):
	guard let code = queue.makeCommandBuffer() else {exitErr(#file,#line,-1);return}
    guard let draw = layer.nextDrawable() else {exitErr(#file,#line,-1);return}
	param[sub]!.colorAttachments[0].texture = draw.texture
	param[sub]!.colorAttachments[0].loadAction = .clear
	param[sub]!.depthAttachment.loadAction = .clear
	if (array.count == 0) {
		guard let encode = code.makeRenderCommandEncoder(descriptor:param[sub]!) else {exitErr(#file,#line,-1);return}
		encode.endEncoding()
	}
	for range in array { // TODO use start and stop
		guard let encode = code.makeRenderCommandEncoder(descriptor:param[sub]!) else {exitErr(#file,#line,-1);return}
		encode.setRenderPipelineState(render[sub]!)
		encode.setDepthStencilState(depth[sub]!)
		encode.setVertexBuffer(triangle.get(),offset:0,index:0)
		encode.setVertexBuffer(vertex.get(),offset:0,index:1)
		encode.setVertexBuffer(matrix.get(),offset:0,index:2)
		encode.setVertexBuffer(uniform.get(),offset:0,index:3)
		encode.drawPrimitives(
			type:.triangle,
			vertexStart:Int(range.idx),
			vertexCount:Int(range.siz))
		encode.endEncoding()
		param[sub]!.colorAttachments[0].loadAction = .load
		param[sub]!.depthAttachment.loadAction = .load
	}
	code.present(draw)
	code.addScheduledHandler(getLock())
	code.addCompletedHandler(getCount())
	count += 1
	code.commit()
	case (Compute):
	guard let code = queue.makeCommandBuffer() else {exitErr(#file,#line,-1);return}
	for range in array { // TODO use start and stopf
		var offset = (Int(range.idx)*MemoryLayout<Triangle>.size)/3
		var nums:[Int] = []
		var pers:[Int] = []
		let quotient = (Int(range.siz)/threads[sub]!.width)/3
		let remainder = (Int(range.siz)%threads[sub]!.width)/3
		if (quotient > 0) {
			nums.append(quotient)
			pers.append(threads[sub]!.width)}
		if (remainder > 0) {
			nums.append(1)
			pers.append(remainder)}
		for (n,p) in zip(nums,pers) {
			guard let encode = code.makeComputeCommandEncoder() else {exitErr(#file,#line,-1);return}
			encode.setComputePipelineState(compute[sub]!)
			encode.setBuffer(triangle.get(),offset:offset,index:0)
			encode.setBuffer(numeric.get(),offset:0,index:1)
			encode.setBuffer(vertex.get(),offset:0,index:2)
			encode.setBuffer(matrix.get(),offset:0,index:3)
			encode.setBuffer(uniform.get(),offset:0,index:4)
			encode.setBuffer(pierce.get(),offset:0,index:5)
			let num = MTLSize(width:n,height:1,depth:1)
			let per = MTLSize(width:p,height:1,depth:1)
			encode.dispatchThreadgroups(num,threadsPerThreadgroup:per)
			encode.endEncoding()
			offset += n*p*MemoryLayout<Triangle>.size
		}
	}
	code.addCompletedHandler(getReady())
	code.addScheduledHandler(getLock())
	code.addCompletedHandler(getCount())
	count += 1
	code.commit()
	default: exitErr(#file,#line,-1);return
	}
}

// MAIN

	planeInit(swiftInit,swiftRun,swiftMemory,swiftWake,swiftInfo,swiftDraw)
