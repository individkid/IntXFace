This is a collection of processes that communicate by pipe.
They read double dash files to specify polytopes, sounds, and manipulation modes.
Mouse motion can transform view, polytope, or plane.
Mouse clicks can add plane, add region, or remove region.
Asynchronous appends to double dash files wake up the file process
to change the state of other processes.

The theory file proves that naive.hs is algorithmic.

The make include file depend.mk is auto-generated
by building all nameable files until no new ones are built,
and examining the files for dependencies.

face.c face.h facer.lua facer.hs facer.c test fork exec read write processes.
This has fork/exec/block read*/write* *Int/*Num/*Str/*New/*Old
for int/double/char*/longlong/float to/from processes in each language.

type.gen generates type.h type.c type.hs type.lua typer.h typer.c typer.hs typer.lua.
This has declarations and read*/write* for each struct/enum in each language.

file.h file.c filer.lua test read write monitor append files.
Main pselects on interface pipe,
waiting for commands.
Open file command opens the helper named pipe for writing,
creates a pthread with unnamed pipe,
and opens given file.
Write command forwards to indicated named pipe.
Main pselects unnamed pipes and interface pipe.
The created pthread round robin lock reads from given files til eof,
and tries for writelock on youngest helper file,
or waits for readlock.
The writelocker waits for commands in the named pipe,
lock changes the given file,
appends to the helper file,
writes to the unnamed pipe,
opens younger helper file if current one is too long,
and loops back.
The readlocker reads the appended command,
writes to the unnamed pipe,
and loops back.

trade.c trader.lua test read write to files on other servers.
local commands are mapped to local file of file on other server.
remote commands are mapped to local file.
responses are mapped to local or remote processes.

merge.c merger.lua test keep common fields in files synchronized.
Control commands can pause and resume merging,
overwrite from one file to another,
change the synchronize frequency,
or change the file topology.
A control command sends callback command
with latest state of field for merging,
and sends callback again for remerging as glitch.

line.c liner.lua linra.c test stock flow sound system.
This allows simple sums of terms of coefficient
with one or two variable factors or three variable conditional
to schedule evaluations, variable changes, and interface writes on a timewheel.
Interface reads can change the set variables, their simple sums,
their values, or which is used for sound.

plane.c planer.lua planra.c test opengl display mouse keyboard.
This has four shaders, one to find pierce points,
one to display facets, one to stream framebuffers,
and one to detect focal point proximity to planes.
This maintains a global transformation matrix,
a matrix per polytope,
one for manipulating individual planes,
copies of the matrices from when fixed point is saved,
copies from when matrices are sent to synchronize with other processes.
There are functions to modify a matrices by translation and rotation,
and a function to three way merge matrices.
Handles merge callbacks while waiting for synchronize write.

space.hs Naive.hs spacer.lua spacra.hs test specify examine sample classify.
This keeps track of which side of boundaries regions are on,
classifies planes as boundaries, samples boundaries as planes,
classifies sets of regions as polytopes, samples polytopes as region sets,
finds super- sub- co- space section,
produces points and element arrays for opengl.

sculpt.lua starts file plane space to manipulate double dash polytopes.
This converts double dash commands in files
to and from commands this and other processes.

print.lua starts file space to find and tweak inflated spaces or tetrahedron overlaps.
This applies heuristics to samples from space
to find canonical examples of complete classes of spaces and overlaps,
and writes specifications to double dash files.

play.lua starts file line plane space to record user polytope sound interact.
This reads double dash files at the rate they were written,
inserts user manipulations and activations,
writes the result to a new double dash file,
while sound follows and alters polytope appearance metric configuration.
Each vertex is a harmonic pattern. The vertice's facet metrics control
loudness (where zero visible volume is too soft to hear),
harmonic set frequency (visible area of zero is too high to hear),
rhythm set duty cycle (zero visible length is too much silence between attacks to wait for).

ball.lua banks the focal point off of framebuffer decorated portions of planes.
This starts a shader that detects when any of a swarm of detector points,
surrounding the focal point, crosses a plane,
triggering a script to change the motion of the focal point,
while mouse and roller change velocity and speed of the focal point.
This also starts a shader that detects when decorated portions of planes
become visible, so framebuffer textures can be dedicated for them.
This also distorts sounds to hammer home which lines of sight are broken.

world.lua moves focal point towards or through pierce point.
Moving through a pierce point can add a user to a permissions group.
Users have read, write, and execute permissions in their groups.
Execute permission is a graph instead of a hierarchy.
Each user may create decorated boundaries for groups they have write permission in.
Decorations include posts, remote framebuffers, altenate spaces, and system sound.

main.lua combine commands from sculpt print play ball world.
